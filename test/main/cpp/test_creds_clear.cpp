/**
 * Copyright 2020-2021 Comcast Cable Communications Management, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * SPDX-License-Identifier: Apache-2.0
 */

#include "sec_security_utils.h"
#include "test_creds.h"
#include "test_ctx.h"
#include <memory>

unsigned char sym128_a_bin[] = {
        0x05, 0xe8, 0x38, 0x84, 0xc4, 0x0c, 0x0a, 0xd8, 0x20, 0x79, 0x9e, 0xb5, 0x81, 0xf8, 0x74, 0x28};

unsigned int sym128_a_bin_len = 16;

unsigned char sym160_a_bin[] = {
        0xaa, 0xbe, 0xf6, 0x0b, 0x97, 0x3a, 0x55, 0xc0, 0x3d, 0xa0, 0xdd, 0x85, 0xef, 0xb3, 0xbd, 0xc0,
        0x2f, 0x09, 0x32, 0x88};

unsigned int sym160_a_bin_len = 20;

unsigned char sym256_a_bin[] = {
        0x6f, 0x08, 0x2b, 0xb5, 0xa9, 0xb9, 0x27, 0x3b, 0xd5, 0x4b, 0xaf, 0xfb, 0xe9, 0x63, 0xc7, 0xd2,
        0xad, 0xde, 0xf1, 0x68, 0x87, 0x07, 0xdb, 0xc5, 0xbf, 0x7c, 0x2b, 0x33, 0x5f, 0x29, 0x99, 0x44};

unsigned int sym256_a_bin_len = 32;

unsigned char rsa1024_der[] = {
        0x30, 0x82, 0x02, 0x5d, 0x02, 0x01, 0x00, 0x02, 0x81, 0x81, 0x00, 0xc4, 0x32, 0x70, 0x15, 0xb3,
        0x53, 0xd5, 0xaf, 0x26, 0xc2, 0xcd, 0x6e, 0x87, 0x9f, 0x13, 0x10, 0x9e, 0x3d, 0x8d, 0x6c, 0xb4,
        0x1e, 0xc8, 0xbb, 0xf1, 0xbf, 0x7a, 0xc0, 0xce, 0xbf, 0x5c, 0x00, 0x1f, 0x83, 0xd8, 0xe3, 0xf7,
        0xe8, 0xa3, 0x79, 0x61, 0xd4, 0x3a, 0xae, 0x49, 0x6d, 0x38, 0x1d, 0x12, 0x74, 0xba, 0x9c, 0xb4,
        0x38, 0x61, 0x6b, 0x44, 0x1d, 0xac, 0xf7, 0xa7, 0x7d, 0x8a, 0x80, 0x9f, 0x56, 0x67, 0xb2, 0xe5,
        0x45, 0xbc, 0x0d, 0xde, 0xde, 0x63, 0x06, 0x13, 0x4d, 0x06, 0x2e, 0xe2, 0xf9, 0xfa, 0xe4, 0x3b,
        0xa6, 0xa0, 0x49, 0xbb, 0x11, 0x23, 0xf8, 0x68, 0x85, 0x3c, 0x1b, 0x92, 0xe1, 0x6c, 0x42, 0x37,
        0xe3, 0x1b, 0x7c, 0x7a, 0x25, 0x91, 0x30, 0xd5, 0xa5, 0xf3, 0xbb, 0x91, 0x23, 0xdf, 0x23, 0x94,
        0xb8, 0xf2, 0x61, 0x4f, 0xba, 0x73, 0xd1, 0x4b, 0x2b, 0x89, 0x8f, 0x02, 0x03, 0x01, 0x00, 0x01,
        0x02, 0x81, 0x81, 0x00, 0x8c, 0x8d, 0xad, 0xaa, 0x7e, 0x2b, 0xe2, 0xfb, 0x75, 0x83, 0x3c, 0xf4,
        0xa0, 0x08, 0x1f, 0xfa, 0x59, 0xc2, 0xb2, 0xdc, 0x5b, 0x35, 0x6a, 0x8c, 0xea, 0x25, 0x48, 0xe5,
        0x73, 0xb7, 0xb7, 0x4b, 0x07, 0x48, 0xc7, 0x4a, 0x99, 0xc1, 0x79, 0xcb, 0x6d, 0x80, 0x43, 0x01,
        0xb4, 0xec, 0x9f, 0xb4, 0x84, 0x12, 0x47, 0xd6, 0x17, 0x6e, 0x04, 0xac, 0x79, 0xc1, 0xe0, 0xb6,
        0x12, 0xb1, 0x67, 0x54, 0x77, 0xa2, 0xd4, 0x80, 0xf2, 0x87, 0xb9, 0x56, 0xcc, 0xde, 0xc2, 0x52,
        0x09, 0x2d, 0x5b, 0x7b, 0x0e, 0xfa, 0xe2, 0xd8, 0x9e, 0x41, 0xaf, 0xfc, 0x42, 0x0d, 0x24, 0x6c,
        0xe2, 0x8b, 0x3a, 0xae, 0x5c, 0x17, 0x11, 0xbb, 0x33, 0x13, 0xb8, 0x66, 0xd6, 0xc6, 0xb1, 0x2f,
        0xef, 0xf0, 0x68, 0x0e, 0x2c, 0xf9, 0x41, 0xd2, 0x7f, 0xe0, 0x15, 0xe2, 0x33, 0xf5, 0xd8, 0xb6,
        0x01, 0xb0, 0x64, 0x91, 0x02, 0x41, 0x00, 0xf3, 0x37, 0x23, 0xf9, 0xff, 0x24, 0x37, 0x63, 0x10,
        0x19, 0x6f, 0x6c, 0x35, 0xa0, 0x41, 0x3c, 0x2c, 0x00, 0xa8, 0x71, 0xa9, 0x09, 0x0e, 0x1f, 0xc7,
        0x87, 0x6e, 0x67, 0xf3, 0x8a, 0x76, 0x5f, 0xfb, 0x69, 0x44, 0x22, 0x88, 0x36, 0x1d, 0x31, 0xb9,
        0x79, 0xd3, 0x8c, 0x92, 0xb4, 0x0c, 0x0b, 0x72, 0xdd, 0x62, 0x47, 0x86, 0xd7, 0x7d, 0x63, 0xb1,
        0xe3, 0x30, 0xb4, 0x8f, 0x89, 0x63, 0x3b, 0x02, 0x41, 0x00, 0xce, 0x82, 0x96, 0xa8, 0x5c, 0x6a,
        0x8a, 0x50, 0x31, 0xf1, 0x9c, 0xe3, 0xaa, 0x0d, 0x89, 0xe4, 0xe2, 0x68, 0xe2, 0x25, 0xf7, 0xec,
        0x5e, 0xe8, 0xde, 0x68, 0x29, 0x84, 0xf2, 0x58, 0x68, 0xa8, 0xb3, 0x1b, 0x36, 0x68, 0x7c, 0x2d,
        0x21, 0xea, 0x92, 0xb5, 0x3a, 0x80, 0xc2, 0x45, 0xbb, 0xc4, 0xfc, 0x38, 0xb0, 0x33, 0xe2, 0xf1,
        0x93, 0x83, 0x48, 0x5d, 0x91, 0x31, 0xc4, 0x55, 0x65, 0xbd, 0x02, 0x40, 0x0e, 0x66, 0x2d, 0x53,
        0x17, 0xaf, 0xe5, 0x37, 0x90, 0x34, 0x71, 0x4c, 0x4e, 0xc0, 0x76, 0x1c, 0x41, 0xde, 0xa8, 0x1a,
        0x52, 0x8f, 0x9e, 0xae, 0x72, 0xf9, 0xa9, 0xa7, 0xad, 0xdb, 0x7c, 0xb6, 0xa2, 0x03, 0xd1, 0x6c,
        0xd9, 0xf3, 0x9a, 0x36, 0xdf, 0x6c, 0x3f, 0x02, 0x0b, 0x8d, 0x6d, 0x49, 0x20, 0x3b, 0xcb, 0x1d,
        0xc0, 0xf5, 0xf1, 0x0e, 0x7d, 0xf1, 0x9d, 0x68, 0x93, 0x36, 0xe7, 0x11, 0x02, 0x40, 0x4c, 0x12,
        0x93, 0x09, 0x26, 0x32, 0x21, 0x0d, 0x75, 0xb8, 0x79, 0x80, 0xec, 0x4d, 0xdc, 0x74, 0x32, 0x6b,
        0x4c, 0x93, 0x8c, 0x06, 0xc8, 0xd7, 0xa3, 0xc6, 0x5f, 0x35, 0x18, 0x49, 0x35, 0x14, 0xa0, 0x15,
        0xf0, 0x2f, 0x01, 0x3f, 0x66, 0xf5, 0x10, 0x62, 0x2e, 0x50, 0xec, 0x3f, 0xdf, 0xf1, 0xaa, 0xaf,
        0xff, 0x48, 0xbd, 0xdb, 0x1b, 0xea, 0x0a, 0xa8, 0x5d, 0x2a, 0x26, 0x17, 0x07, 0x49, 0x02, 0x41,
        0x00, 0xb6, 0xc4, 0x4b, 0x68, 0x82, 0xe8, 0x40, 0xc0, 0x70, 0x58, 0xdb, 0x68, 0x49, 0x30, 0x7d,
        0x6a, 0xf1, 0xfc, 0x9d, 0x66, 0x33, 0x10, 0x28, 0x1b, 0x54, 0x1d, 0x81, 0xf1, 0x88, 0x9a, 0x6b,
        0xb7, 0x1b, 0x7f, 0x36, 0x79, 0xce, 0x02, 0xec, 0x7c, 0x7e, 0x71, 0x37, 0x05, 0x46, 0x33, 0xee,
        0x3d, 0x71, 0x8f, 0xb6, 0x16, 0x6c, 0xa6, 0x64, 0xa9, 0xe4, 0x04, 0xc8, 0x12, 0xd7, 0x14, 0xcf,
        0xed};

unsigned int rsa1024_der_len = 609;

unsigned char rsa1024_pub_der[] = {
        0x30, 0x81, 0x9f, 0x30, 0x0d, 0x06, 0x09, 0x2a, 0x86, 0x48, 0x86, 0xf7, 0x0d, 0x01, 0x01, 0x01,
        0x05, 0x00, 0x03, 0x81, 0x8d, 0x00, 0x30, 0x81, 0x89, 0x02, 0x81, 0x81, 0x00, 0xc4, 0x32, 0x70,
        0x15, 0xb3, 0x53, 0xd5, 0xaf, 0x26, 0xc2, 0xcd, 0x6e, 0x87, 0x9f, 0x13, 0x10, 0x9e, 0x3d, 0x8d,
        0x6c, 0xb4, 0x1e, 0xc8, 0xbb, 0xf1, 0xbf, 0x7a, 0xc0, 0xce, 0xbf, 0x5c, 0x00, 0x1f, 0x83, 0xd8,
        0xe3, 0xf7, 0xe8, 0xa3, 0x79, 0x61, 0xd4, 0x3a, 0xae, 0x49, 0x6d, 0x38, 0x1d, 0x12, 0x74, 0xba,
        0x9c, 0xb4, 0x38, 0x61, 0x6b, 0x44, 0x1d, 0xac, 0xf7, 0xa7, 0x7d, 0x8a, 0x80, 0x9f, 0x56, 0x67,
        0xb2, 0xe5, 0x45, 0xbc, 0x0d, 0xde, 0xde, 0x63, 0x06, 0x13, 0x4d, 0x06, 0x2e, 0xe2, 0xf9, 0xfa,
        0xe4, 0x3b, 0xa6, 0xa0, 0x49, 0xbb, 0x11, 0x23, 0xf8, 0x68, 0x85, 0x3c, 0x1b, 0x92, 0xe1, 0x6c,
        0x42, 0x37, 0xe3, 0x1b, 0x7c, 0x7a, 0x25, 0x91, 0x30, 0xd5, 0xa5, 0xf3, 0xbb, 0x91, 0x23, 0xdf,
        0x23, 0x94, 0xb8, 0xf2, 0x61, 0x4f, 0xba, 0x73, 0xd1, 0x4b, 0x2b, 0x89, 0x8f, 0x02, 0x03, 0x01,
        0x00, 0x01};

unsigned int rsa1024_pub_der_len = 162;

unsigned char rsa2048_der[] = {
        0x30, 0x82, 0x04, 0xa3, 0x02, 0x01, 0x00, 0x02, 0x82, 0x01, 0x01, 0x00, 0xf2, 0x6a, 0x52, 0xa0,
        0x96, 0xc5, 0xb7, 0x86, 0x6f, 0xc4, 0x35, 0x39, 0x5e, 0x28, 0xd3, 0xa6, 0xab, 0x80, 0x6a, 0xbb,
        0x07, 0x10, 0x74, 0xea, 0xe0, 0xfc, 0xef, 0x54, 0xb0, 0x5e, 0x66, 0x34, 0x21, 0x89, 0x35, 0x09,
        0xb7, 0x46, 0xf8, 0xb6, 0xf8, 0x86, 0xc0, 0x55, 0xc6, 0xc5, 0x2e, 0x36, 0xcc, 0xb7, 0x24, 0x5e,
        0x56, 0xba, 0x2b, 0x8d, 0xfb, 0x8d, 0x7b, 0xe1, 0x4b, 0x9e, 0xdf, 0x08, 0x5c, 0xb2, 0x28, 0xc0,
        0x79, 0x45, 0xd1, 0xf3, 0x9c, 0x70, 0xd8, 0xaf, 0x50, 0x1c, 0xc3, 0x10, 0x24, 0x84, 0xc1, 0xb1,
        0x36, 0x3f, 0xd4, 0xbf, 0x10, 0x18, 0xf9, 0xd0, 0x72, 0xea, 0xce, 0xbf, 0x34, 0x8e, 0xb5, 0x97,
        0xcb, 0x8a, 0x5e, 0x8e, 0x7d, 0xed, 0x1f, 0xe3, 0xa9, 0xde, 0x5b, 0x3f, 0xc9, 0x33, 0x4c, 0x9b,
        0x3e, 0xd8, 0x29, 0x61, 0x6b, 0x30, 0xba, 0xa1, 0x36, 0xbd, 0x22, 0x33, 0xa1, 0x25, 0x73, 0xab,
        0x5f, 0x6f, 0x35, 0x48, 0xf1, 0xad, 0x96, 0x5f, 0x0d, 0x0c, 0xe5, 0xe9, 0x8d, 0xf9, 0xed, 0x0c,
        0xcf, 0x50, 0x3c, 0x24, 0x34, 0x9b, 0x9e, 0xbc, 0xf9, 0xfa, 0x19, 0x51, 0x37, 0x03, 0x5c, 0xd0,
        0x25, 0x1f, 0xe6, 0xb2, 0xf7, 0xff, 0x96, 0xb0, 0x61, 0x42, 0xbb, 0xc5, 0x64, 0x5f, 0x3d, 0xaf,
        0x6f, 0x14, 0xcc, 0x92, 0x74, 0x6a, 0x06, 0xfa, 0xb2, 0xd9, 0xe1, 0x4d, 0x42, 0x76, 0xab, 0x88,
        0xe3, 0x08, 0xa2, 0xad, 0x00, 0xb6, 0xf7, 0x78, 0x0c, 0xba, 0x08, 0x71, 0xbc, 0x8d, 0x98, 0x43,
        0x12, 0x63, 0x8d, 0x5e, 0x1f, 0x49, 0xb9, 0x5f, 0x0d, 0x55, 0x1a, 0x90, 0x63, 0x4c, 0xd8, 0xe8,
        0x0b, 0x9f, 0x3d, 0x10, 0xb4, 0xf9, 0x1b, 0x44, 0x3f, 0x43, 0xad, 0x35, 0x42, 0x3d, 0x3d, 0x21,
        0x8e, 0xa8, 0x08, 0x28, 0x47, 0x19, 0x14, 0x28, 0x1c, 0x95, 0xb7, 0x5d, 0x02, 0x03, 0x01, 0x00,
        0x01, 0x02, 0x82, 0x01, 0x00, 0x17, 0xd3, 0x1d, 0x45, 0xcd, 0x2b, 0xa7, 0x6a, 0xde, 0x07, 0x31,
        0x97, 0xee, 0xca, 0x22, 0x6b, 0x0a, 0x05, 0xf7, 0xf7, 0x63, 0xad, 0x59, 0x60, 0x50, 0x36, 0x6b,
        0xab, 0x2e, 0x1e, 0x48, 0xfb, 0x2c, 0xa4, 0x98, 0x82, 0xd8, 0xf1, 0x6f, 0xb6, 0x43, 0xdc, 0xb2,
        0x80, 0x7b, 0xa5, 0x9b, 0x72, 0x25, 0x52, 0x86, 0x8f, 0x83, 0x04, 0x8f, 0x0d, 0x48, 0x40, 0xd2,
        0x81, 0x04, 0xf6, 0x9b, 0x42, 0xee, 0x21, 0x50, 0x62, 0x02, 0x49, 0x3b, 0x66, 0x2e, 0xe4, 0xe4,
        0x56, 0xee, 0x8f, 0xb5, 0x18, 0x1c, 0x0e, 0xb4, 0x1e, 0x9f, 0x8f, 0x4c, 0x70, 0x6e, 0xbb, 0x95,
        0xa9, 0xc7, 0xf1, 0x8d, 0xda, 0x3a, 0xe7, 0x1f, 0xaf, 0xc8, 0x80, 0x53, 0xe4, 0xbb, 0x39, 0x97,
        0xdd, 0xbf, 0x2f, 0x2c, 0x56, 0xab, 0x86, 0x90, 0x2b, 0xdd, 0xd4, 0x4e, 0xd4, 0xd5, 0x3d, 0x17,
        0xca, 0x8a, 0x5f, 0xb2, 0x41, 0xa1, 0xc6, 0x52, 0x80, 0xe5, 0xf0, 0x7a, 0xda, 0x35, 0xa5, 0x36,
        0xb9, 0x61, 0x15, 0x60, 0x39, 0x2f, 0x04, 0x1f, 0x6e, 0xee, 0x99, 0xee, 0xa5, 0x21, 0xcc, 0x4f,
        0xa3, 0x4e, 0x06, 0xc5, 0xbc, 0xa5, 0x34, 0xd6, 0x10, 0x57, 0x36, 0x85, 0xf7, 0x0a, 0x34, 0xfb,
        0xa5, 0x6b, 0x71, 0x9c, 0x4a, 0x43, 0x4a, 0xd0, 0xcb, 0xb4, 0x9a, 0xac, 0x4f, 0x9a, 0x29, 0xe8,
        0x68, 0x15, 0x00, 0xe4, 0x6c, 0x34, 0xc3, 0x73, 0x7e, 0xb5, 0x16, 0x2a, 0x17, 0x37, 0xc0, 0xb6,
        0xaf, 0x81, 0xb4, 0x73, 0xf2, 0xd3, 0x9f, 0xaa, 0x40, 0x73, 0x28, 0x0d, 0xfd, 0xb4, 0x67, 0x6e,
        0x82, 0xa8, 0x13, 0x34, 0xc0, 0x54, 0x88, 0xaf, 0x85, 0x6f, 0xd8, 0x33, 0x84, 0x82, 0xb5, 0xd0,
        0x5f, 0x7f, 0x21, 0xca, 0x6d, 0x86, 0x74, 0xb3, 0x89, 0x81, 0x19, 0x45, 0x47, 0x38, 0x41, 0x53,
        0x47, 0x86, 0xc6, 0xcd, 0x9d, 0x02, 0x81, 0x81, 0x00, 0xfd, 0x90, 0x23, 0xf9, 0xba, 0xc5, 0x69,
        0x7d, 0x11, 0xed, 0x69, 0x57, 0x73, 0x1d, 0x06, 0xe8, 0x1b, 0x37, 0x00, 0x69, 0x95, 0xc5, 0x63,
        0x86, 0x3f, 0xda, 0xb4, 0x11, 0xad, 0x69, 0x55, 0xf4, 0x76, 0x3c, 0xa0, 0x95, 0x65, 0x60, 0x29,
        0xb9, 0x69, 0x79, 0xca, 0x74, 0x50, 0xe3, 0x98, 0xc7, 0x90, 0xd7, 0xb8, 0xd4, 0xc5, 0x51, 0x10,
        0xa3, 0x10, 0x72, 0xf3, 0xdc, 0x91, 0xb4, 0xee, 0xdd, 0x9a, 0x57, 0xf1, 0x1b, 0x0e, 0xba, 0x0f,
        0x67, 0x1a, 0x94, 0x86, 0x36, 0x69, 0x20, 0xd5, 0x6b, 0x80, 0x50, 0x7d, 0x20, 0x53, 0xeb, 0xed,
        0x8a, 0xc5, 0xbc, 0xcb, 0x13, 0xb9, 0x0d, 0x49, 0x22, 0x7c, 0xeb, 0xa6, 0x97, 0x5a, 0x5b, 0x92,
        0x3a, 0x3d, 0x93, 0x5b, 0x86, 0x2c, 0x75, 0x0b, 0xfa, 0x68, 0xa6, 0xc1, 0x68, 0x07, 0x37, 0x01,
        0x9b, 0xd1, 0x51, 0xfe, 0xc0, 0x4c, 0x2d, 0x15, 0x9f, 0x02, 0x81, 0x81, 0x00, 0xf4, 0xbe, 0xc1,
        0x32, 0xad, 0xca, 0x28, 0x37, 0x7c, 0x17, 0x99, 0xde, 0x64, 0x9b, 0xc1, 0xf8, 0x23, 0x6a, 0xde,
        0xd8, 0x01, 0x59, 0x09, 0x10, 0x67, 0xb8, 0x27, 0xc5, 0xe6, 0xee, 0xf8, 0x16, 0x7c, 0x46, 0xa0,
        0x0b, 0x00, 0xf9, 0xff, 0x72, 0x4b, 0xde, 0x65, 0x65, 0xb6, 0xaa, 0x44, 0x1a, 0xbc, 0xdf, 0x13,
        0x15, 0x08, 0x80, 0xa5, 0xb4, 0xdd, 0xcd, 0xe0, 0x34, 0x4a, 0x85, 0x31, 0x82, 0x17, 0x57, 0x5a,
        0xea, 0x21, 0x38, 0x26, 0xdf, 0x48, 0x59, 0x1d, 0x58, 0x5b, 0x9f, 0x04, 0x12, 0xee, 0x5b, 0xa2,
        0xa9, 0xb3, 0xfe, 0x83, 0xa7, 0xda, 0x47, 0xc6, 0xfb, 0x89, 0x77, 0x1f, 0x3a, 0xbc, 0x7c, 0xc7,
        0x13, 0xc9, 0xb8, 0xdc, 0xb0, 0x9e, 0xa7, 0x2a, 0xa5, 0x2c, 0x3b, 0x96, 0xe2, 0x2e, 0xc0, 0xcf,
        0xfa, 0x0c, 0xe0, 0x2d, 0xad, 0xaa, 0x7f, 0x85, 0x4b, 0x6f, 0x04, 0xf9, 0x83, 0x02, 0x81, 0x81,
        0x00, 0xca, 0x8f, 0xd2, 0xdd, 0x96, 0xc2, 0x4c, 0x52, 0x58, 0xf7, 0x03, 0x77, 0x94, 0x03, 0x75,
        0x58, 0x09, 0x1d, 0xb8, 0x5b, 0xa1, 0x05, 0x4e, 0x4b, 0x9a, 0x49, 0x5a, 0x1e, 0xe1, 0x1c, 0xcc,
        0x48, 0xfe, 0x07, 0xd2, 0xf5, 0x66, 0x46, 0x1b, 0x2e, 0xfe, 0xbf, 0x07, 0xe8, 0x42, 0x12, 0x80,
        0x23, 0xb5, 0x67, 0x50, 0x45, 0xd1, 0xd7, 0xbf, 0xe5, 0xb4, 0xa7, 0x50, 0x7f, 0x3d, 0x7b, 0x80,
        0x73, 0x51, 0xf0, 0xbd, 0x31, 0x33, 0x63, 0x9a, 0x18, 0x70, 0xd8, 0x84, 0x1b, 0x85, 0x82, 0x70,
        0x5c, 0x6f, 0xe6, 0x5c, 0xff, 0x6d, 0x6b, 0x85, 0x99, 0x9d, 0xfc, 0x03, 0x73, 0x9f, 0x1a, 0xa8,
        0xf9, 0x3f, 0x38, 0x76, 0x1e, 0x65, 0x55, 0xd0, 0x0c, 0x6c, 0xd2, 0x82, 0x84, 0x3e, 0x91, 0xc6,
        0xde, 0xe5, 0xa9, 0x89, 0xca, 0x54, 0x31, 0x32, 0x3c, 0xcb, 0x4c, 0xa8, 0xa9, 0xf0, 0x70, 0xf7,
        0xdb, 0x02, 0x81, 0x80, 0x62, 0x16, 0xd9, 0xa3, 0x90, 0x17, 0x87, 0x8a, 0xc5, 0x47, 0x48, 0x39,
        0xe3, 0xa4, 0xb1, 0x56, 0xdc, 0x0b, 0x07, 0x09, 0x17, 0x71, 0x31, 0xba, 0xcb, 0x76, 0xf9, 0x29,
        0xcd, 0xe6, 0x54, 0xb3, 0xde, 0x57, 0x07, 0xe9, 0xa1, 0x18, 0x91, 0x12, 0xa3, 0xe9, 0x9c, 0x45,
        0xe9, 0xb1, 0xcf, 0xdd, 0xcf, 0x78, 0xb0, 0x53, 0x2b, 0xb7, 0x33, 0xb2, 0x8b, 0x7a, 0xe9, 0xb2,
        0xcb, 0x73, 0x1a, 0x66, 0x83, 0x28, 0x55, 0x9d, 0xa4, 0x76, 0xb6, 0xcd, 0xa2, 0x57, 0x64, 0xf5,
        0x76, 0xb3, 0x02, 0x94, 0xfb, 0xc6, 0xea, 0x28, 0x8d, 0xa5, 0x21, 0xea, 0xf2, 0x06, 0xf6, 0x6e,
        0xf5, 0xa7, 0x32, 0x72, 0xfd, 0xfc, 0x1c, 0x65, 0x87, 0xe1, 0x79, 0x41, 0xa8, 0x34, 0x63, 0x59,
        0x13, 0xa3, 0x46, 0x53, 0x9c, 0x5d, 0x56, 0x7d, 0x67, 0x0f, 0xa9, 0xff, 0x02, 0x68, 0x5d, 0x69,
        0xe0, 0x32, 0xe4, 0x35, 0x02, 0x81, 0x80, 0x55, 0xf8, 0x25, 0x84, 0x94, 0xad, 0x50, 0xab, 0x49,
        0x38, 0x30, 0xaf, 0xde, 0x53, 0xdc, 0x27, 0x08, 0x25, 0x27, 0x5a, 0xd2, 0xe5, 0x21, 0x50, 0xde,
        0x6d, 0x6b, 0xc7, 0x17, 0xae, 0x21, 0xb6, 0xcb, 0xe9, 0x24, 0x7c, 0x76, 0x32, 0xe3, 0xcb, 0xba,
        0xee, 0x61, 0xd2, 0x79, 0xf2, 0x88, 0x12, 0x1c, 0x9f, 0x29, 0xb3, 0x6a, 0x73, 0x16, 0xfc, 0x35,
        0xcf, 0xe7, 0x68, 0xec, 0x47, 0xf7, 0xfb, 0x2d, 0x18, 0xff, 0xa8, 0xbf, 0xe1, 0xe8, 0x64, 0xa0,
        0x98, 0x4a, 0x70, 0x07, 0x5d, 0xb1, 0x8e, 0x6e, 0x15, 0x4e, 0x0d, 0x28, 0x61, 0xb1, 0x37, 0x21,
        0xcb, 0xba, 0x1d, 0x1b, 0xff, 0x06, 0x9f, 0xbe, 0xbc, 0xa9, 0x93, 0x77, 0x07, 0xc1, 0xc0, 0x1a,
        0x4b, 0x13, 0xee, 0xa3, 0xdb, 0x7e, 0x99, 0x94, 0xcc, 0x5b, 0x88, 0xfb, 0xb9, 0x77, 0x3c, 0x81,
        0x80, 0x5d, 0xef, 0x3e, 0xf8, 0x6e, 0xfa};

unsigned int rsa2048_der_len = 1191;

unsigned char rsa2048_pub_der[] = {
        0x30, 0x82, 0x01, 0x22, 0x30, 0x0d, 0x06, 0x09, 0x2a, 0x86, 0x48, 0x86, 0xf7, 0x0d, 0x01, 0x01,
        0x01, 0x05, 0x00, 0x03, 0x82, 0x01, 0x0f, 0x00, 0x30, 0x82, 0x01, 0x0a, 0x02, 0x82, 0x01, 0x01,
        0x00, 0xf2, 0x6a, 0x52, 0xa0, 0x96, 0xc5, 0xb7, 0x86, 0x6f, 0xc4, 0x35, 0x39, 0x5e, 0x28, 0xd3,
        0xa6, 0xab, 0x80, 0x6a, 0xbb, 0x07, 0x10, 0x74, 0xea, 0xe0, 0xfc, 0xef, 0x54, 0xb0, 0x5e, 0x66,
        0x34, 0x21, 0x89, 0x35, 0x09, 0xb7, 0x46, 0xf8, 0xb6, 0xf8, 0x86, 0xc0, 0x55, 0xc6, 0xc5, 0x2e,
        0x36, 0xcc, 0xb7, 0x24, 0x5e, 0x56, 0xba, 0x2b, 0x8d, 0xfb, 0x8d, 0x7b, 0xe1, 0x4b, 0x9e, 0xdf,
        0x08, 0x5c, 0xb2, 0x28, 0xc0, 0x79, 0x45, 0xd1, 0xf3, 0x9c, 0x70, 0xd8, 0xaf, 0x50, 0x1c, 0xc3,
        0x10, 0x24, 0x84, 0xc1, 0xb1, 0x36, 0x3f, 0xd4, 0xbf, 0x10, 0x18, 0xf9, 0xd0, 0x72, 0xea, 0xce,
        0xbf, 0x34, 0x8e, 0xb5, 0x97, 0xcb, 0x8a, 0x5e, 0x8e, 0x7d, 0xed, 0x1f, 0xe3, 0xa9, 0xde, 0x5b,
        0x3f, 0xc9, 0x33, 0x4c, 0x9b, 0x3e, 0xd8, 0x29, 0x61, 0x6b, 0x30, 0xba, 0xa1, 0x36, 0xbd, 0x22,
        0x33, 0xa1, 0x25, 0x73, 0xab, 0x5f, 0x6f, 0x35, 0x48, 0xf1, 0xad, 0x96, 0x5f, 0x0d, 0x0c, 0xe5,
        0xe9, 0x8d, 0xf9, 0xed, 0x0c, 0xcf, 0x50, 0x3c, 0x24, 0x34, 0x9b, 0x9e, 0xbc, 0xf9, 0xfa, 0x19,
        0x51, 0x37, 0x03, 0x5c, 0xd0, 0x25, 0x1f, 0xe6, 0xb2, 0xf7, 0xff, 0x96, 0xb0, 0x61, 0x42, 0xbb,
        0xc5, 0x64, 0x5f, 0x3d, 0xaf, 0x6f, 0x14, 0xcc, 0x92, 0x74, 0x6a, 0x06, 0xfa, 0xb2, 0xd9, 0xe1,
        0x4d, 0x42, 0x76, 0xab, 0x88, 0xe3, 0x08, 0xa2, 0xad, 0x00, 0xb6, 0xf7, 0x78, 0x0c, 0xba, 0x08,
        0x71, 0xbc, 0x8d, 0x98, 0x43, 0x12, 0x63, 0x8d, 0x5e, 0x1f, 0x49, 0xb9, 0x5f, 0x0d, 0x55, 0x1a,
        0x90, 0x63, 0x4c, 0xd8, 0xe8, 0x0b, 0x9f, 0x3d, 0x10, 0xb4, 0xf9, 0x1b, 0x44, 0x3f, 0x43, 0xad,
        0x35, 0x42, 0x3d, 0x3d, 0x21, 0x8e, 0xa8, 0x08, 0x28, 0x47, 0x19, 0x14, 0x28, 0x1c, 0x95, 0xb7,
        0x5d, 0x02, 0x03, 0x01, 0x00, 0x01};
unsigned int rsa2048_pub_der_len = 294;

unsigned char rsa1024_cert_der[] = {
        0x30, 0x82, 0x02, 0xb4, 0x30, 0x82, 0x02, 0x1d, 0xa0, 0x03, 0x02, 0x01, 0x02, 0x02, 0x09, 0x00,
        0xc4, 0x52, 0xc1, 0x4a, 0x9e, 0x74, 0xe8, 0xa8, 0x30, 0x0d, 0x06, 0x09, 0x2a, 0x86, 0x48, 0x86,
        0xf7, 0x0d, 0x01, 0x01, 0x05, 0x05, 0x00, 0x30, 0x73, 0x31, 0x0b, 0x30, 0x09, 0x06, 0x03, 0x55,
        0x04, 0x06, 0x13, 0x02, 0x55, 0x53, 0x31, 0x11, 0x30, 0x0f, 0x06, 0x03, 0x55, 0x04, 0x08, 0x0c,
        0x08, 0x4d, 0x61, 0x72, 0x79, 0x6c, 0x61, 0x6e, 0x64, 0x31, 0x11, 0x30, 0x0f, 0x06, 0x03, 0x55,
        0x04, 0x07, 0x0c, 0x08, 0x43, 0x6f, 0x6c, 0x75, 0x6d, 0x62, 0x69, 0x61, 0x31, 0x10, 0x30, 0x0e,
        0x06, 0x03, 0x55, 0x04, 0x0a, 0x0c, 0x07, 0x43, 0x6f, 0x6d, 0x63, 0x61, 0x73, 0x74, 0x31, 0x0f,
        0x30, 0x0d, 0x06, 0x03, 0x55, 0x04, 0x0b, 0x0c, 0x06, 0x43, 0x6f, 0x6e, 0x73, 0x65, 0x63, 0x31,
        0x1b, 0x30, 0x19, 0x06, 0x03, 0x55, 0x04, 0x03, 0x0c, 0x12, 0x63, 0x6f, 0x6e, 0x73, 0x65, 0x63,
        0x2e, 0x63, 0x6f, 0x6d, 0x63, 0x61, 0x73, 0x74, 0x2e, 0x63, 0x6f, 0x6d, 0x30, 0x1e, 0x17, 0x0d,
        0x31, 0x35, 0x30, 0x36, 0x32, 0x33, 0x30, 0x33, 0x30, 0x35, 0x31, 0x36, 0x5a, 0x17, 0x0d, 0x31,
        0x35, 0x30, 0x37, 0x32, 0x33, 0x30, 0x33, 0x30, 0x35, 0x31, 0x36, 0x5a, 0x30, 0x73, 0x31, 0x0b,
        0x30, 0x09, 0x06, 0x03, 0x55, 0x04, 0x06, 0x13, 0x02, 0x55, 0x53, 0x31, 0x11, 0x30, 0x0f, 0x06,
        0x03, 0x55, 0x04, 0x08, 0x0c, 0x08, 0x4d, 0x61, 0x72, 0x79, 0x6c, 0x61, 0x6e, 0x64, 0x31, 0x11,
        0x30, 0x0f, 0x06, 0x03, 0x55, 0x04, 0x07, 0x0c, 0x08, 0x43, 0x6f, 0x6c, 0x75, 0x6d, 0x62, 0x69,
        0x61, 0x31, 0x10, 0x30, 0x0e, 0x06, 0x03, 0x55, 0x04, 0x0a, 0x0c, 0x07, 0x43, 0x6f, 0x6d, 0x63,
        0x61, 0x73, 0x74, 0x31, 0x0f, 0x30, 0x0d, 0x06, 0x03, 0x55, 0x04, 0x0b, 0x0c, 0x06, 0x43, 0x6f,
        0x6e, 0x73, 0x65, 0x63, 0x31, 0x1b, 0x30, 0x19, 0x06, 0x03, 0x55, 0x04, 0x03, 0x0c, 0x12, 0x63,
        0x6f, 0x6e, 0x73, 0x65, 0x63, 0x2e, 0x63, 0x6f, 0x6d, 0x63, 0x61, 0x73, 0x74, 0x2e, 0x63, 0x6f,
        0x6d, 0x30, 0x81, 0x9f, 0x30, 0x0d, 0x06, 0x09, 0x2a, 0x86, 0x48, 0x86, 0xf7, 0x0d, 0x01, 0x01,
        0x01, 0x05, 0x00, 0x03, 0x81, 0x8d, 0x00, 0x30, 0x81, 0x89, 0x02, 0x81, 0x81, 0x00, 0xc4, 0x32,
        0x70, 0x15, 0xb3, 0x53, 0xd5, 0xaf, 0x26, 0xc2, 0xcd, 0x6e, 0x87, 0x9f, 0x13, 0x10, 0x9e, 0x3d,
        0x8d, 0x6c, 0xb4, 0x1e, 0xc8, 0xbb, 0xf1, 0xbf, 0x7a, 0xc0, 0xce, 0xbf, 0x5c, 0x00, 0x1f, 0x83,
        0xd8, 0xe3, 0xf7, 0xe8, 0xa3, 0x79, 0x61, 0xd4, 0x3a, 0xae, 0x49, 0x6d, 0x38, 0x1d, 0x12, 0x74,
        0xba, 0x9c, 0xb4, 0x38, 0x61, 0x6b, 0x44, 0x1d, 0xac, 0xf7, 0xa7, 0x7d, 0x8a, 0x80, 0x9f, 0x56,
        0x67, 0xb2, 0xe5, 0x45, 0xbc, 0x0d, 0xde, 0xde, 0x63, 0x06, 0x13, 0x4d, 0x06, 0x2e, 0xe2, 0xf9,
        0xfa, 0xe4, 0x3b, 0xa6, 0xa0, 0x49, 0xbb, 0x11, 0x23, 0xf8, 0x68, 0x85, 0x3c, 0x1b, 0x92, 0xe1,
        0x6c, 0x42, 0x37, 0xe3, 0x1b, 0x7c, 0x7a, 0x25, 0x91, 0x30, 0xd5, 0xa5, 0xf3, 0xbb, 0x91, 0x23,
        0xdf, 0x23, 0x94, 0xb8, 0xf2, 0x61, 0x4f, 0xba, 0x73, 0xd1, 0x4b, 0x2b, 0x89, 0x8f, 0x02, 0x03,
        0x01, 0x00, 0x01, 0xa3, 0x50, 0x30, 0x4e, 0x30, 0x1d, 0x06, 0x03, 0x55, 0x1d, 0x0e, 0x04, 0x16,
        0x04, 0x14, 0x76, 0x63, 0x9b, 0x06, 0xa5, 0x12, 0x26, 0xa5, 0x89, 0xc6, 0x6c, 0x57, 0x5b, 0x4a,
        0x3e, 0x47, 0xb0, 0xa4, 0x0b, 0x1a, 0x30, 0x1f, 0x06, 0x03, 0x55, 0x1d, 0x23, 0x04, 0x18, 0x30,
        0x16, 0x80, 0x14, 0x76, 0x63, 0x9b, 0x06, 0xa5, 0x12, 0x26, 0xa5, 0x89, 0xc6, 0x6c, 0x57, 0x5b,
        0x4a, 0x3e, 0x47, 0xb0, 0xa4, 0x0b, 0x1a, 0x30, 0x0c, 0x06, 0x03, 0x55, 0x1d, 0x13, 0x04, 0x05,
        0x30, 0x03, 0x01, 0x01, 0xff, 0x30, 0x0d, 0x06, 0x09, 0x2a, 0x86, 0x48, 0x86, 0xf7, 0x0d, 0x01,
        0x01, 0x05, 0x05, 0x00, 0x03, 0x81, 0x81, 0x00, 0x33, 0xbe, 0xfe, 0x79, 0xdb, 0x9b, 0xc2, 0x09,
        0xb8, 0x9c, 0x51, 0x6a, 0x2b, 0x5f, 0xe5, 0xc6, 0xc6, 0xd2, 0x72, 0x5d, 0x56, 0x24, 0xa1, 0xa5,
        0xac, 0x28, 0xbc, 0xba, 0x60, 0xb9, 0xd6, 0x30, 0x39, 0x4e, 0x89, 0xc9, 0x41, 0x89, 0x37, 0xf0,
        0xeb, 0xee, 0x09, 0x31, 0xb0, 0x34, 0xed, 0xf6, 0x8f, 0x70, 0xd3, 0x65, 0x81, 0x18, 0x1c, 0xbe,
        0xd0, 0x08, 0x94, 0x1d, 0x80, 0x92, 0x72, 0x8f, 0x16, 0xa4, 0xac, 0xf4, 0x7d, 0x1e, 0xe1, 0x8b,
        0xe7, 0x79, 0x26, 0x4b, 0xc8, 0x17, 0x3e, 0x19, 0xf5, 0x50, 0x07, 0xd0, 0x85, 0xb6, 0xeb, 0x56,
        0xff, 0xdb, 0xe2, 0x28, 0x42, 0x58, 0x52, 0xf3, 0xef, 0x6a, 0xf8, 0x86, 0xae, 0x9e, 0xa2, 0x7c,
        0xa2, 0xb7, 0x87, 0x90, 0x1b, 0x48, 0xdc, 0x7d, 0x2a, 0xf2, 0x0c, 0x55, 0xf3, 0x34, 0x79, 0xb3,
        0x87, 0x67, 0x18, 0x29, 0xc8, 0x3a, 0xc9, 0xe3};
unsigned int rsa1024_cert_der_len = 696;

unsigned char rsa2048_cert_der[] = {
        0x30, 0x82, 0x03, 0xb9, 0x30, 0x82, 0x02, 0xa1, 0xa0, 0x03, 0x02, 0x01, 0x02, 0x02, 0x09, 0x00,
        0xee, 0x91, 0x7a, 0x08, 0x9a, 0x55, 0x9f, 0x5f, 0x30, 0x0d, 0x06, 0x09, 0x2a, 0x86, 0x48, 0x86,
        0xf7, 0x0d, 0x01, 0x01, 0x05, 0x05, 0x00, 0x30, 0x73, 0x31, 0x0b, 0x30, 0x09, 0x06, 0x03, 0x55,
        0x04, 0x06, 0x13, 0x02, 0x55, 0x53, 0x31, 0x11, 0x30, 0x0f, 0x06, 0x03, 0x55, 0x04, 0x08, 0x0c,
        0x08, 0x4d, 0x61, 0x72, 0x79, 0x6c, 0x61, 0x6e, 0x64, 0x31, 0x11, 0x30, 0x0f, 0x06, 0x03, 0x55,
        0x04, 0x07, 0x0c, 0x08, 0x43, 0x6f, 0x6c, 0x75, 0x6d, 0x62, 0x69, 0x61, 0x31, 0x0f, 0x30, 0x0d,
        0x06, 0x03, 0x55, 0x04, 0x0a, 0x0c, 0x06, 0x43, 0x6f, 0x6e, 0x73, 0x65, 0x63, 0x31, 0x10, 0x30,
        0x0e, 0x06, 0x03, 0x55, 0x04, 0x0b, 0x0c, 0x07, 0x43, 0x6f, 0x6d, 0x63, 0x61, 0x73, 0x74, 0x31,
        0x1b, 0x30, 0x19, 0x06, 0x03, 0x55, 0x04, 0x03, 0x0c, 0x12, 0x63, 0x6f, 0x6e, 0x73, 0x65, 0x63,
        0x2e, 0x63, 0x6f, 0x6d, 0x63, 0x61, 0x73, 0x74, 0x2e, 0x63, 0x6f, 0x6d, 0x30, 0x1e, 0x17, 0x0d,
        0x31, 0x35, 0x30, 0x36, 0x32, 0x33, 0x30, 0x33, 0x30, 0x36, 0x30, 0x37, 0x5a, 0x17, 0x0d, 0x31,
        0x35, 0x30, 0x37, 0x32, 0x33, 0x30, 0x33, 0x30, 0x36, 0x30, 0x37, 0x5a, 0x30, 0x73, 0x31, 0x0b,
        0x30, 0x09, 0x06, 0x03, 0x55, 0x04, 0x06, 0x13, 0x02, 0x55, 0x53, 0x31, 0x11, 0x30, 0x0f, 0x06,
        0x03, 0x55, 0x04, 0x08, 0x0c, 0x08, 0x4d, 0x61, 0x72, 0x79, 0x6c, 0x61, 0x6e, 0x64, 0x31, 0x11,
        0x30, 0x0f, 0x06, 0x03, 0x55, 0x04, 0x07, 0x0c, 0x08, 0x43, 0x6f, 0x6c, 0x75, 0x6d, 0x62, 0x69,
        0x61, 0x31, 0x0f, 0x30, 0x0d, 0x06, 0x03, 0x55, 0x04, 0x0a, 0x0c, 0x06, 0x43, 0x6f, 0x6e, 0x73,
        0x65, 0x63, 0x31, 0x10, 0x30, 0x0e, 0x06, 0x03, 0x55, 0x04, 0x0b, 0x0c, 0x07, 0x43, 0x6f, 0x6d,
        0x63, 0x61, 0x73, 0x74, 0x31, 0x1b, 0x30, 0x19, 0x06, 0x03, 0x55, 0x04, 0x03, 0x0c, 0x12, 0x63,
        0x6f, 0x6e, 0x73, 0x65, 0x63, 0x2e, 0x63, 0x6f, 0x6d, 0x63, 0x61, 0x73, 0x74, 0x2e, 0x63, 0x6f,
        0x6d, 0x30, 0x82, 0x01, 0x22, 0x30, 0x0d, 0x06, 0x09, 0x2a, 0x86, 0x48, 0x86, 0xf7, 0x0d, 0x01,
        0x01, 0x01, 0x05, 0x00, 0x03, 0x82, 0x01, 0x0f, 0x00, 0x30, 0x82, 0x01, 0x0a, 0x02, 0x82, 0x01,
        0x01, 0x00, 0xf2, 0x6a, 0x52, 0xa0, 0x96, 0xc5, 0xb7, 0x86, 0x6f, 0xc4, 0x35, 0x39, 0x5e, 0x28,
        0xd3, 0xa6, 0xab, 0x80, 0x6a, 0xbb, 0x07, 0x10, 0x74, 0xea, 0xe0, 0xfc, 0xef, 0x54, 0xb0, 0x5e,
        0x66, 0x34, 0x21, 0x89, 0x35, 0x09, 0xb7, 0x46, 0xf8, 0xb6, 0xf8, 0x86, 0xc0, 0x55, 0xc6, 0xc5,
        0x2e, 0x36, 0xcc, 0xb7, 0x24, 0x5e, 0x56, 0xba, 0x2b, 0x8d, 0xfb, 0x8d, 0x7b, 0xe1, 0x4b, 0x9e,
        0xdf, 0x08, 0x5c, 0xb2, 0x28, 0xc0, 0x79, 0x45, 0xd1, 0xf3, 0x9c, 0x70, 0xd8, 0xaf, 0x50, 0x1c,
        0xc3, 0x10, 0x24, 0x84, 0xc1, 0xb1, 0x36, 0x3f, 0xd4, 0xbf, 0x10, 0x18, 0xf9, 0xd0, 0x72, 0xea,
        0xce, 0xbf, 0x34, 0x8e, 0xb5, 0x97, 0xcb, 0x8a, 0x5e, 0x8e, 0x7d, 0xed, 0x1f, 0xe3, 0xa9, 0xde,
        0x5b, 0x3f, 0xc9, 0x33, 0x4c, 0x9b, 0x3e, 0xd8, 0x29, 0x61, 0x6b, 0x30, 0xba, 0xa1, 0x36, 0xbd,
        0x22, 0x33, 0xa1, 0x25, 0x73, 0xab, 0x5f, 0x6f, 0x35, 0x48, 0xf1, 0xad, 0x96, 0x5f, 0x0d, 0x0c,
        0xe5, 0xe9, 0x8d, 0xf9, 0xed, 0x0c, 0xcf, 0x50, 0x3c, 0x24, 0x34, 0x9b, 0x9e, 0xbc, 0xf9, 0xfa,
        0x19, 0x51, 0x37, 0x03, 0x5c, 0xd0, 0x25, 0x1f, 0xe6, 0xb2, 0xf7, 0xff, 0x96, 0xb0, 0x61, 0x42,
        0xbb, 0xc5, 0x64, 0x5f, 0x3d, 0xaf, 0x6f, 0x14, 0xcc, 0x92, 0x74, 0x6a, 0x06, 0xfa, 0xb2, 0xd9,
        0xe1, 0x4d, 0x42, 0x76, 0xab, 0x88, 0xe3, 0x08, 0xa2, 0xad, 0x00, 0xb6, 0xf7, 0x78, 0x0c, 0xba,
        0x08, 0x71, 0xbc, 0x8d, 0x98, 0x43, 0x12, 0x63, 0x8d, 0x5e, 0x1f, 0x49, 0xb9, 0x5f, 0x0d, 0x55,
        0x1a, 0x90, 0x63, 0x4c, 0xd8, 0xe8, 0x0b, 0x9f, 0x3d, 0x10, 0xb4, 0xf9, 0x1b, 0x44, 0x3f, 0x43,
        0xad, 0x35, 0x42, 0x3d, 0x3d, 0x21, 0x8e, 0xa8, 0x08, 0x28, 0x47, 0x19, 0x14, 0x28, 0x1c, 0x95,
        0xb7, 0x5d, 0x02, 0x03, 0x01, 0x00, 0x01, 0xa3, 0x50, 0x30, 0x4e, 0x30, 0x1d, 0x06, 0x03, 0x55,
        0x1d, 0x0e, 0x04, 0x16, 0x04, 0x14, 0xf0, 0xe1, 0x4e, 0x26, 0x9b, 0xa4, 0xc8, 0x7c, 0x24, 0x2d,
        0xa2, 0xdc, 0x5e, 0x3e, 0xb8, 0x64, 0xb0, 0xb7, 0x3e, 0x96, 0x30, 0x1f, 0x06, 0x03, 0x55, 0x1d,
        0x23, 0x04, 0x18, 0x30, 0x16, 0x80, 0x14, 0xf0, 0xe1, 0x4e, 0x26, 0x9b, 0xa4, 0xc8, 0x7c, 0x24,
        0x2d, 0xa2, 0xdc, 0x5e, 0x3e, 0xb8, 0x64, 0xb0, 0xb7, 0x3e, 0x96, 0x30, 0x0c, 0x06, 0x03, 0x55,
        0x1d, 0x13, 0x04, 0x05, 0x30, 0x03, 0x01, 0x01, 0xff, 0x30, 0x0d, 0x06, 0x09, 0x2a, 0x86, 0x48,
        0x86, 0xf7, 0x0d, 0x01, 0x01, 0x05, 0x05, 0x00, 0x03, 0x82, 0x01, 0x01, 0x00, 0x68, 0x60, 0x3a,
        0x9a, 0xcf, 0x75, 0x6c, 0x09, 0xab, 0x9a, 0x4a, 0x0d, 0x9b, 0xe4, 0x7f, 0xdc, 0x7a, 0xa9, 0xfa,
        0x06, 0xb4, 0xc4, 0xca, 0xcf, 0xa0, 0x38, 0x7f, 0xdf, 0xc2, 0x4d, 0x4a, 0x94, 0x82, 0x33, 0x83,
        0x9a, 0x7b, 0x9b, 0x84, 0xf7, 0xfd, 0xb3, 0x93, 0x22, 0xd0, 0xb2, 0x73, 0xa8, 0x54, 0x45, 0xb0,
        0x05, 0xac, 0x1a, 0xff, 0x60, 0x03, 0x54, 0xa7, 0x0d, 0xcb, 0x8d, 0xeb, 0x62, 0x59, 0xcb, 0x8b,
        0xfa, 0x7f, 0x8d, 0xd8, 0xa4, 0x64, 0x3a, 0x3e, 0xdc, 0x5d, 0xb9, 0xc0, 0x27, 0x50, 0xd0, 0x54,
        0x62, 0x1e, 0xe7, 0x7f, 0x66, 0xa8, 0xdf, 0xbc, 0x6a, 0x17, 0xf1, 0xcd, 0x45, 0x76, 0x34, 0xc3,
        0x6c, 0x6f, 0xac, 0x85, 0x50, 0xdc, 0xd4, 0xf0, 0xdd, 0x85, 0xfa, 0x75, 0x23, 0x45, 0x12, 0x90,
        0x0d, 0xf2, 0xc9, 0x43, 0x83, 0x4c, 0x97, 0xfd, 0x76, 0x64, 0xa8, 0x80, 0x15, 0x45, 0x4a, 0xa4,
        0x36, 0xc7, 0xa5, 0x12, 0x09, 0x4d, 0xc1, 0xdb, 0xc0, 0xbe, 0x58, 0x9b, 0x16, 0xe6, 0x6f, 0x63,
        0xed, 0x5c, 0x62, 0xd6, 0x23, 0xb0, 0x26, 0x46, 0xb1, 0x98, 0x5c, 0x94, 0x72, 0x86, 0x2f, 0x26,
        0xa1, 0x91, 0x68, 0x4a, 0x5c, 0x01, 0x8b, 0x44, 0x00, 0xea, 0xa4, 0x61, 0x85, 0x4b, 0xd4, 0xc3,
        0x50, 0x16, 0x97, 0xa4, 0x6f, 0x56, 0x2f, 0x2a, 0xf0, 0x6e, 0x3f, 0x35, 0x6e, 0xe5, 0x27, 0x3c,
        0x76, 0xa9, 0x91, 0x6b, 0x1f, 0x1e, 0x73, 0x82, 0x61, 0xcc, 0x06, 0x2d, 0xae, 0x12, 0x49, 0x66,
        0xa6, 0x86, 0x39, 0x65, 0x00, 0x77, 0x22, 0x92, 0x64, 0x9c, 0x12, 0x30, 0x24, 0x75, 0x8b, 0xd7,
        0x02, 0x7a, 0x5b, 0xbe, 0x15, 0xda, 0x0e, 0xac, 0x9c, 0xfe, 0xb1, 0xc8, 0x6c, 0x25, 0xf8, 0xea,
        0x0a, 0x69, 0x64, 0xb7, 0x5e, 0x60, 0x65, 0xba, 0x02, 0xe4, 0xf5, 0x66, 0x07};

unsigned int rsa2048_cert_der_len = 957;

unsigned char ecc_der[] = {
        0x30, 0x77, 0x02, 0x01, 0x01, 0x04, 0x20, 0x4d, 0xef, 0x8c, 0x19, 0x60, 0xf5, 0xd6, 0x78, 0x18,
        0x84, 0x4d, 0xe6, 0xe3, 0x2f, 0x19, 0x4f, 0xcd, 0x10, 0xc5, 0xfd, 0x55, 0x54, 0xc1, 0x7e, 0x95,
        0x4e, 0xbc, 0xe1, 0xba, 0xba, 0x56, 0xc6, 0xa0, 0x0a, 0x06, 0x08, 0x2a, 0x86, 0x48, 0xce, 0x3d,
        0x03, 0x01, 0x07, 0xa1, 0x44, 0x03, 0x42, 0x00, 0x04, 0x7f, 0xd8, 0x8a, 0x21, 0x09, 0x41, 0xb2,
        0x02, 0x5b, 0x1d, 0xb0, 0x2e, 0xa5, 0x04, 0x6e, 0xae, 0xae, 0x21, 0xd8, 0x02, 0x8e, 0xaa, 0x3b,
        0x68, 0x03, 0x6e, 0x25, 0xd6, 0x2c, 0x08, 0xff, 0xa6, 0x13, 0x5a, 0x8c, 0x14, 0xe0, 0x93, 0x66,
        0xa2, 0x25, 0x46, 0x75, 0x8f, 0xd6, 0x87, 0x79, 0xb4, 0xc2, 0x62, 0x7e, 0xa8, 0xed, 0x45, 0xb1,
        0xe5, 0x91, 0xb6, 0x2b, 0xd4, 0x2a, 0xbb, 0x2d, 0x94};

unsigned int ecc_der_len = 121;

unsigned char ecc_pub_der[] = {
        0x30, 0x59, 0x30, 0x13, 0x06, 0x07, 0x2a, 0x86, 0x48, 0xce, 0x3d, 0x02, 0x01, 0x06, 0x08, 0x2a,
        0x86, 0x48, 0xce, 0x3d, 0x03, 0x01, 0x07, 0x03, 0x42, 0x00, 0x04, 0x7f, 0xd8, 0x8a, 0x21, 0x09,
        0x41, 0xb2, 0x02, 0x5b, 0x1d, 0xb0, 0x2e, 0xa5, 0x04, 0x6e, 0xae, 0xae, 0x21, 0xd8, 0x02, 0x8e,
        0xaa, 0x3b, 0x68, 0x03, 0x6e, 0x25, 0xd6, 0x2c, 0x08, 0xff, 0xa6, 0x13, 0x5a, 0x8c, 0x14, 0xe0,
        0x93, 0x66, 0xa2, 0x25, 0x46, 0x75, 0x8f, 0xd6, 0x87, 0x79, 0xb4, 0xc2, 0x62, 0x7e, 0xa8, 0xed,
        0x45, 0xb1, 0xe5, 0x91, 0xb6, 0x2b, 0xd4, 0x2a, 0xbb, 0x2d, 0x94};

unsigned int ecc_pub_der_len = 91;

unsigned char ecc_cert_der[] = {
        0x30, 0x82, 0x01, 0x7a, 0x30, 0x82, 0x01, 0x20, 0x02, 0x09, 0x00, 0xa6, 0x4e, 0x60, 0x8c, 0xa5,
        0xe7, 0x04, 0x98, 0x30, 0x0a, 0x06, 0x08, 0x2a, 0x86, 0x48, 0xce, 0x3d, 0x04, 0x03, 0x02, 0x30,
        0x45, 0x31, 0x0b, 0x30, 0x09, 0x06, 0x03, 0x55, 0x04, 0x06, 0x13, 0x02, 0x41, 0x55, 0x31, 0x13,
        0x30, 0x11, 0x06, 0x03, 0x55, 0x04, 0x08, 0x0c, 0x0a, 0x53, 0x6f, 0x6d, 0x65, 0x2d, 0x53, 0x74,
        0x61, 0x74, 0x65, 0x31, 0x21, 0x30, 0x1f, 0x06, 0x03, 0x55, 0x04, 0x0a, 0x0c, 0x18, 0x49, 0x6e,
        0x74, 0x65, 0x72, 0x6e, 0x65, 0x74, 0x20, 0x57, 0x69, 0x64, 0x67, 0x69, 0x74, 0x73, 0x20, 0x50,
        0x74, 0x79, 0x20, 0x4c, 0x74, 0x64, 0x30, 0x1e, 0x17, 0x0d, 0x31, 0x38, 0x31, 0x30, 0x30, 0x39,
        0x31, 0x38, 0x31, 0x35, 0x33, 0x31, 0x5a, 0x17, 0x0d, 0x31, 0x38, 0x31, 0x31, 0x30, 0x38, 0x31,
        0x38, 0x31, 0x35, 0x33, 0x31, 0x5a, 0x30, 0x45, 0x31, 0x0b, 0x30, 0x09, 0x06, 0x03, 0x55, 0x04,
        0x06, 0x13, 0x02, 0x41, 0x55, 0x31, 0x13, 0x30, 0x11, 0x06, 0x03, 0x55, 0x04, 0x08, 0x0c, 0x0a,
        0x53, 0x6f, 0x6d, 0x65, 0x2d, 0x53, 0x74, 0x61, 0x74, 0x65, 0x31, 0x21, 0x30, 0x1f, 0x06, 0x03,
        0x55, 0x04, 0x0a, 0x0c, 0x18, 0x49, 0x6e, 0x74, 0x65, 0x72, 0x6e, 0x65, 0x74, 0x20, 0x57, 0x69,
        0x64, 0x67, 0x69, 0x74, 0x73, 0x20, 0x50, 0x74, 0x79, 0x20, 0x4c, 0x74, 0x64, 0x30, 0x59, 0x30,
        0x13, 0x06, 0x07, 0x2a, 0x86, 0x48, 0xce, 0x3d, 0x02, 0x01, 0x06, 0x08, 0x2a, 0x86, 0x48, 0xce,
        0x3d, 0x03, 0x01, 0x07, 0x03, 0x42, 0x00, 0x04, 0x7f, 0xd8, 0x8a, 0x21, 0x09, 0x41, 0xb2, 0x02,
        0x5b, 0x1d, 0xb0, 0x2e, 0xa5, 0x04, 0x6e, 0xae, 0xae, 0x21, 0xd8, 0x02, 0x8e, 0xaa, 0x3b, 0x68,
        0x03, 0x6e, 0x25, 0xd6, 0x2c, 0x08, 0xff, 0xa6, 0x13, 0x5a, 0x8c, 0x14, 0xe0, 0x93, 0x66, 0xa2,
        0x25, 0x46, 0x75, 0x8f, 0xd6, 0x87, 0x79, 0xb4, 0xc2, 0x62, 0x7e, 0xa8, 0xed, 0x45, 0xb1, 0xe5,
        0x91, 0xb6, 0x2b, 0xd4, 0x2a, 0xbb, 0x2d, 0x94, 0x30, 0x0a, 0x06, 0x08, 0x2a, 0x86, 0x48, 0xce,
        0x3d, 0x04, 0x03, 0x02, 0x03, 0x48, 0x00, 0x30, 0x45, 0x02, 0x21, 0x00, 0xad, 0xfc, 0x19, 0xb8,
        0xc3, 0x87, 0x8d, 0x52, 0x3a, 0xf5, 0x83, 0xc6, 0x58, 0xc5, 0x86, 0x3b, 0xd5, 0xce, 0x74, 0x85,
        0x66, 0xd5, 0xbc, 0xfe, 0x5f, 0xd1, 0x75, 0xe3, 0x42, 0xe1, 0x5a, 0x00, 0x02, 0x20, 0x7c, 0x9c,
        0xb8, 0x45, 0x9e, 0xe7, 0x3a, 0x52, 0x9b, 0x2c, 0x92, 0xf3, 0x1b, 0x93, 0x65, 0x47, 0xb3, 0xf1,
        0x1b, 0xf4, 0xf6, 0x50, 0xd2, 0xf4, 0xcb, 0x25, 0x38, 0x21, 0xcb, 0x43, 0xae, 0x7a};

unsigned int ecc_cert_der_len = 382;

unsigned char test_root[] = {
        0xe7, 0x9b, 0x03, 0x18, 0x85, 0x1b, 0x9d, 0xbd, 0xd7, 0x17, 0x18, 0xf9, 0xec, 0x72, 0xf0, 0x3d};

unsigned int test_root_len = 16;

struct TestKeyData {
    Sec_KeyType type;
    Sec_KeyContainer kc;
    SEC_BYTE* buffer;
    SEC_SIZE buffer_len;
} __attribute__((aligned(32)));

static TestKeyData g_keyData[TESTKEY_NUM] = {
        {SEC_KEYTYPE_AES_128, SEC_KEYCONTAINER_RAW_AES_128, sym128_a_bin, sym128_a_bin_len},                       //TESTKEY_AES128_A
        {SEC_KEYTYPE_AES_256, SEC_KEYCONTAINER_RAW_AES_256, sym256_a_bin, sym256_a_bin_len},                       //TESTKEY_AES256_A
        {SEC_KEYTYPE_HMAC_128, SEC_KEYCONTAINER_RAW_HMAC_128, sym128_a_bin, sym128_a_bin_len},                     //TESTKEY_HMAC128_A
        {SEC_KEYTYPE_HMAC_160, SEC_KEYCONTAINER_RAW_HMAC_160, sym160_a_bin, sym160_a_bin_len},                     //TESTKEY_HMAC160_A
        {SEC_KEYTYPE_HMAC_256, SEC_KEYCONTAINER_RAW_HMAC_256, sym256_a_bin, sym256_a_bin_len},                     //TESTKEY_HMAC256_A
        {SEC_KEYTYPE_RSA_1024, SEC_KEYCONTAINER_DER_RSA_1024, rsa1024_der, rsa1024_der_len},                       //TESTKEY_RSA1024_SGN_PRIV
        {SEC_KEYTYPE_RSA_1024_PUBLIC, SEC_KEYCONTAINER_DER_RSA_1024_PUBLIC, rsa1024_pub_der, rsa1024_pub_der_len}, //TESTKEY_RSA1024_SGN_PUB
        {SEC_KEYTYPE_RSA_1024, SEC_KEYCONTAINER_DER_RSA_1024, rsa1024_der, rsa1024_der_len},                       //TESTKEY_RSA1024_ENC_PRIV
        {SEC_KEYTYPE_RSA_1024_PUBLIC, SEC_KEYCONTAINER_DER_RSA_1024_PUBLIC, rsa1024_pub_der, rsa1024_pub_der_len}, //TESTKEY_RSA1024_ENC_PUB
        {SEC_KEYTYPE_RSA_1024, SEC_KEYCONTAINER_DER_RSA_1024, rsa1024_der, rsa1024_der_len},                       //TESTKEY_RSA1024_KEK_PRIV
        {SEC_KEYTYPE_RSA_1024_PUBLIC, SEC_KEYCONTAINER_DER_RSA_1024_PUBLIC, rsa1024_pub_der, rsa1024_pub_der_len}, //TESTKEY_RSA1024_KEK_PUB
        {SEC_KEYTYPE_RSA_2048, SEC_KEYCONTAINER_DER_RSA_2048, rsa2048_der, rsa2048_der_len},                       //TESTKEY_RSA2048_SGN_PRIV
        {SEC_KEYTYPE_RSA_2048_PUBLIC, SEC_KEYCONTAINER_DER_RSA_2048_PUBLIC, rsa2048_pub_der, rsa2048_pub_der_len}, //TESTKEY_RSA2048_SGN_PUB
        {SEC_KEYTYPE_RSA_2048, SEC_KEYCONTAINER_DER_RSA_2048, rsa2048_der, rsa2048_der_len},                       //TESTKEY_RSA2048_ENC_PRIV
        {SEC_KEYTYPE_RSA_2048_PUBLIC, SEC_KEYCONTAINER_DER_RSA_2048_PUBLIC, rsa2048_pub_der, rsa2048_pub_der_len}, //TESTKEY_RSA2048_ENC_PUB
        {SEC_KEYTYPE_RSA_2048, SEC_KEYCONTAINER_DER_RSA_2048, rsa2048_der, rsa2048_der_len},                       //TESTKEY_RSA2048_KEK_PRIV
        {SEC_KEYTYPE_RSA_2048_PUBLIC, SEC_KEYCONTAINER_DER_RSA_2048_PUBLIC, rsa2048_pub_der, rsa2048_pub_der_len}, //TESTKEY_RSA2048_KEK_PUB
        {SEC_KEYTYPE_ECC_NISTP256, SEC_KEYCONTAINER_DER_ECC_NISTP256, ecc_der, ecc_der_len},                       //TESTKEY_ECC
        {SEC_KEYTYPE_ECC_NISTP256_PUBLIC, SEC_KEYCONTAINER_DER_ECC_NISTP256_PUBLIC, ecc_pub_der, ecc_pub_der_len}, //TESTKEY_ECC_PUB
        {SEC_KEYTYPE_AES_128, SEC_KEYCONTAINER_RAW_AES_128, test_root, test_root_len},                             //TESTKEY_ECC_PUB
};

struct TestCertData { // NOLINT
    Sec_CertificateContainer cc;
    SEC_BYTE* buffer;
    SEC_SIZE buffer_len;
} __attribute__((aligned(16)));

static TestCertData g_certData[TESTKEY_NUM] = {
        {SEC_CERTIFICATECONTAINER_X509_DER, rsa1024_cert_der, rsa1024_cert_der_len}, //TESTCERT_RSA1024
        {SEC_CERTIFICATECONTAINER_X509_DER, rsa2048_cert_der, rsa2048_cert_der_len}, //TESTCERT_RSA2048
        {SEC_CERTIFICATECONTAINER_X509_DER, ecc_cert_der, ecc_cert_der_len},         //TESTCERT_EC
};

static Sec_Result BigNumToBuffer(const BIGNUM* bignum, SEC_BYTE* buffer, SEC_SIZE buffer_len) {
    SEC_SIZE num_bytes;

    memset(buffer, 0, buffer_len);
    num_bytes = BN_num_bytes(bignum);

    if (num_bytes > buffer_len) {
        SEC_LOG_ERROR("Buffer not large enough.  needed: %d, actual: %d", num_bytes, buffer_len);
        return SEC_RESULT_FAILURE;
    }

    BN_bn2bin(bignum, buffer + buffer_len - num_bytes);

    return SEC_RESULT_SUCCESS;
}

ProvKey* TestCreds::getKey(TestKey key, TestKc kc, SEC_OBJECTID id) {
    if (key >= TESTKEY_NUM) {
        SEC_LOG_ERROR("Invalid key: %d", key);
        return nullptr;
    }

    switch (kc) {
        case TESTKC_RAW: {
            auto keyVector = std::vector<SEC_BYTE>(g_keyData[key].buffer,
                    g_keyData[key].buffer + g_keyData[key].buffer_len);
            return new ProvKey(keyVector, g_keyData[key].kc);
        }
        case TESTKC_SOC:
            return TestCreds::getSocKey(key, id);
            break;

        case TESTKC_GENERATED:
        case TESTKC_STORE:
        default:
            break;
    }

    SEC_LOG_ERROR("Unimplemented");
    return nullptr;
}

Sec_KeyType TestCreds::getKeyType(TestKey key) {
    if (key >= TESTKEY_NUM) {
        SEC_LOG_ERROR("Invalid key: %d", key);
        return SEC_KEYTYPE_NUM;
    }

    return g_keyData[key].type;
}

ProvCert* TestCreds::getCert(TestCert cert) {
    if (cert >= TESTCERT_NUM) {
        SEC_LOG_ERROR("Invalid cert: %d", cert);
        return nullptr;
    }

    auto certVector = std::vector<SEC_BYTE>(g_certData[cert].buffer,
            g_certData[cert].buffer + g_certData[cert].buffer_len);
    return new ProvCert(certVector, g_certData[cert].cc);
}

std::vector<SEC_BYTE> TestCreds::asOpenSslAes(TestKey key) {
    return {g_keyData[key].buffer, g_keyData[key].buffer + g_keyData[key].buffer_len};
}

static RSA* RSAFromDERPub(const SEC_BYTE* der, SEC_SIZE der_len) {
    const auto* p = der;
    RSA* rsa = nullptr;

    rsa = d2i_RSAPublicKey(&rsa, &p, der_len);

    if (rsa == nullptr) {
        p = der;
        rsa = d2i_RSA_PUBKEY(&rsa, &p, der_len);
    }

    do {
        if (rsa == nullptr) {
            SEC_LOG_ERROR("Invalid RSA key container");
            break;
        }
    } while (false);

    return rsa;
}

static RSA* RSAFromDERPriv(const SEC_BYTE* der, SEC_SIZE der_len) {
    const auto* p = der;
    PKCS8_PRIV_KEY_INFO* p8 = nullptr;
    EVP_PKEY* evp_key = nullptr;
    RSA* rsa = nullptr;

    do {
        p8 = d2i_PKCS8_PRIV_KEY_INFO(nullptr, &p, der_len);
        if (p8 != nullptr) {
            evp_key = EVP_PKCS82PKEY(p8);
            if (evp_key == nullptr) {
                SEC_LOG_ERROR("EVP_PKCS82PKEY failed");
                break;
            }
        } else {
            evp_key = d2i_AutoPrivateKey(nullptr, &p, der_len);
            if (evp_key == nullptr) {
                SEC_LOG_ERROR("d2i_AutoPrivateKey failed");
                break;
            }
        }

        rsa = EVP_PKEY_get1_RSA(evp_key);
        if (rsa == nullptr) {
            SEC_LOG_ERROR("EVP_PKEY_get1_RSA failed");
            break;
        }
    } while (false);

    SEC_EVPPKEY_FREE(evp_key);

    if (p8 != nullptr) {
        PKCS8_PRIV_KEY_INFO_free(p8);
    }

    return rsa;
}

RSA* TestCreds::asOpenSslRsa(TestKey key) {
    RSA* rsa = nullptr;
    if (g_keyData[key].kc == SEC_KEYCONTAINER_DER_RSA_1024_PUBLIC ||
            g_keyData[key].kc == SEC_KEYCONTAINER_DER_RSA_2048_PUBLIC) {
        rsa = RSAFromDERPub(g_keyData[key].buffer, g_keyData[key].buffer_len);
        if (rsa == nullptr) {
            SEC_LOG_ERROR("SecUtils_RSAFromDERPub failed");
        }
    } else {
        rsa = RSAFromDERPriv(g_keyData[key].buffer, g_keyData[key].buffer_len);
        if (rsa == nullptr) {
            SEC_LOG_ERROR("SecUtils_RSAFromDERPriv failed");
        }
    }

    return rsa;
}

static EC_KEY* ECCFromDERPub(const SEC_BYTE* der, SEC_SIZE der_len) {
    const auto* p = der;
    EC_KEY* ec_key = nullptr;

    ec_key = d2i_EC_PUBKEY(&ec_key, &p, der_len);

    do {
        if (ec_key == nullptr) {
            SEC_LOG_ERROR("Invalid ECC key container");
            break;
        }
    } while (false);

    return ec_key;
}

static EC_KEY* ECCFromDERPriv(const SEC_BYTE* der, SEC_SIZE der_len) {
    const auto* p = der;
    PKCS8_PRIV_KEY_INFO* p8 = nullptr;
    EVP_PKEY* evp_key = nullptr;
    EC_KEY* ecc = nullptr;

    do {
        p8 = d2i_PKCS8_PRIV_KEY_INFO(nullptr, &p, der_len);
        if (p8 != nullptr) {
            evp_key = EVP_PKCS82PKEY(p8);
            if (evp_key == nullptr) {
                SEC_LOG_ERROR("EVP_PKCS82PKEY failed");
                break;
            }
        } else {
            evp_key = d2i_AutoPrivateKey(nullptr, &p, der_len);
            if (evp_key == nullptr) {
                SEC_LOG_ERROR("d2i_AutoPrivateKey failed");
                break;
            }
        }

        ecc = EVP_PKEY_get1_EC_KEY(evp_key);
        if (ecc == nullptr) {
            SEC_LOG_ERROR("EVP_PKEY_get1_EC_KEY failed");
            break;
        }
    } while (false);

    SEC_EVPPKEY_FREE(evp_key);

    if (p8 != nullptr) {
        PKCS8_PRIV_KEY_INFO_free(p8);
    }

    return ecc;
}

EC_KEY* TestCreds::asOpenSslEcKey(TestKey key) {
    EC_KEY* ec = nullptr;
    if (g_keyData[key].kc == SEC_KEYCONTAINER_DER_ECC_NISTP256_PUBLIC) {
        ec = ECCFromDERPub(g_keyData[key].buffer, g_keyData[key].buffer_len);
        if (ec == nullptr) {
            SEC_LOG_ERROR("SecUtils_ECCFromDERPub failed");
        }
    } else {
        ec = ECCFromDERPriv(g_keyData[key].buffer, g_keyData[key].buffer_len);
        if (ec == nullptr) {
            SEC_LOG_ERROR("SecUtils_ECCFromDERPriv failed");
        }
    }

    return ec;
}

EVP_PKEY* TestCreds::asOpenSslEvpPkey(TestKey key) {
    EVP_PKEY* evp_key = nullptr;

    if (SecKey_IsEcc(g_keyData[key].type) == SEC_TRUE) {
        EC_KEY* ec = TestCreds::asOpenSslEcKey(key);
        if (ec == nullptr) {
            SEC_LOG_ERROR("TestCreds::asOpenSslEcKey failed");
            return nullptr;
        }

        evp_key = EVP_PKEY_new();
        if (evp_key == nullptr) {
            SEC_LOG_ERROR("EVP_PKEY_new failed");
            return nullptr;
        }

        if (EVP_PKEY_set1_EC_KEY(evp_key, ec) == 0) {
            SEC_EVPPKEY_FREE(evp_key);
            SEC_ECC_FREE(ec);
            SEC_LOG_ERROR("EVP_PKEY_set1_EC failed");
            return nullptr;
        }
    } else if (SecKey_IsRsa(g_keyData[key].type) == SEC_TRUE) {
        RSA* rsa = TestCreds::asOpenSslRsa(key);
        if (rsa == nullptr) {
            SEC_LOG_ERROR("TestCreds::asOpenSslRsa failed");
            return nullptr;
        }

        evp_key = EVP_PKEY_new();
        if (evp_key == nullptr) {
            SEC_LOG_ERROR("EVP_PKEY_new failed");
            SEC_RSA_FREE(rsa);
            return nullptr;
        }

        if (EVP_PKEY_set1_RSA(evp_key, rsa) == 0) {
            SEC_EVPPKEY_FREE(evp_key);
            SEC_RSA_FREE(rsa);
            SEC_LOG_ERROR("EVP_PKEY_set1_RSA failed");
            return nullptr;
        }

        SEC_RSA_FREE(rsa);
    } else {
        SEC_LOG_ERROR("Not an asymetric key type");
        return nullptr;
    }

    return evp_key;
}

static bool Is_Valid_Point(EC_KEY* ec_key, const std::vector<SEC_BYTE>& data) {
    if (data.size() != SEC_ECC_NISTP256_KEY_LEN) {
        SEC_LOG_ERROR("Input size needed != One BIGNUM");
        return false;
    }

    // Convert the input buffer to be encrypted to a BIGNUM
    std::shared_ptr<BIGNUM> inputAsBN(BN_new(), BN_free);
    if (inputAsBN == nullptr) {
        SEC_LOG_ERROR("BN_new failed");
        return false;
    }

    if (BN_bin2bn(&data[0], static_cast<int>(data.size()), inputAsBN.get()) == nullptr) {
        SEC_LOG_ERROR("BN_bin2bn failed. Error: %s", ERR_error_string(ERR_get_error(), nullptr));
        return false;
    }

    const EC_GROUP* group = EC_KEY_get0_group(ec_key);
    if (group == nullptr) {
        SEC_LOG_ERROR("EC_KEY_get0_group failed");
        return false;
    }

    std::shared_ptr<BN_CTX> ctx(BN_CTX_new(), BN_CTX_free);
    if (ctx == nullptr) {
        SEC_LOG_ERROR("BN_CTX_new failed");
        return false;
    }

    std::shared_ptr<EC_POINT> pt(EC_POINT_new(group), EC_POINT_free);
    if (pt == nullptr) {
        SEC_LOG_ERROR("EC_POINT_new failed");
        return false;
    }

    if (EC_POINT_set_compressed_coordinates_GFp(group, pt.get(), inputAsBN.get(), 0, ctx.get()) != 1) {
        SEC_LOG_ERROR("EC_POINT_set_compressed_coordinates_GFp failed");
        return false;
    }

    return true;
}

static int ElGamal_Encrypt_Rand(EC_KEY* ec_key, SEC_BYTE* input, SEC_SIZE inputSize, SEC_BYTE* output,
        SEC_SIZE outputSize, BIGNUM* sender_rand) {
    int res = -1;
    BIGNUM* inputAsBN = nullptr;
    const EC_GROUP* group = nullptr;
    const EC_POINT* P = nullptr;
    const EC_POINT* PK_recipient = nullptr;
    EC_POINT* shared_secret = nullptr;
    EC_POINT* key_2_wrap_point = nullptr;
    EC_POINT* sender_share = nullptr;
    EC_POINT* wrapped_key = nullptr;
    BIGNUM* x = nullptr;
    BIGNUM* y = nullptr;
    BN_CTX* ctx = nullptr;

    do {
        if (inputSize != SEC_ECC_NISTP256_KEY_LEN) {
            SEC_LOG_ERROR("Input size needed != One BIGNUM");
            break;
        }

        if (outputSize < 4 * SEC_ECC_NISTP256_KEY_LEN) {
            SEC_LOG_ERROR("Output size needed < Four BIGNUMs");
            break;
        }

        // Convert the input buffer to be encrypted to a BIGNUM
        inputAsBN = BN_new();
        if (inputAsBN == nullptr) {
            SEC_LOG_ERROR("BN_new failed");
            break;
        }
        if (BN_bin2bn(input, static_cast<int>(inputSize), inputAsBN) == nullptr) {
            SEC_LOG_ERROR("BN_bin2bn failed. Error: %s",
                    ERR_error_string(ERR_get_error(), nullptr));
            break;
        }

        group = EC_KEY_get0_group(ec_key);
        if (group == nullptr) {
            SEC_LOG_ERROR("EC_KEY_get0_group failed");
            break;
        }

        ctx = BN_CTX_new();
        if (ctx == nullptr) {
            SEC_LOG_ERROR("BN_CTX_new failed");
            break;
        }

        // Convert the X coordinate to an EC Point.  This takes the desired Y value in 1 bit (to choose
        // which of the two possible Y values to use).  This *calculates* an actual Y value for the point.
        key_2_wrap_point = EC_POINT_new(group);
        if (key_2_wrap_point == nullptr) {
            SEC_LOG_ERROR("EC_POINT_new failed");
            break;
        }

        if (EC_POINT_set_compressed_coordinates_GFp(group, key_2_wrap_point, inputAsBN, 0, ctx) != 1) {
            // Don't print an error message if the error is "point not on curve" 100A906E, but still fail
            if (ERR_get_error() != 0x100A906E) // i.e. error:100A906E:lib(16):func(169):reason(110)
            {
                SEC_LOG_ERROR("Set EC_POINT_set_compressed_coordinates_GFp failed. Error: %s",
                        ERR_error_string(ERR_get_error(), nullptr));
            }
            break;
        }

        // Calc sender's shared point 'wP' => this gets sent back to receiver
        sender_share = EC_POINT_new(group);
        if (sender_share == nullptr) {
            SEC_LOG_ERROR("EC_POINT_new failed");
            break;
        }

        P = EC_GROUP_get0_generator(group);
        if (P == nullptr) {
            SEC_LOG_ERROR("EC_GROUP_get0_generator failed");
            break;
        }
        EC_POINT_mul(group, sender_share, nullptr, P, sender_rand, ctx);

        // Calc sender's Shared Secret 'wRr'  => this hides the key I want to send
        shared_secret = EC_POINT_new(group);
        if (shared_secret == nullptr) {
            SEC_LOG_ERROR("EC_POINT_new failed");
            break;
        }

        PK_recipient = EC_KEY_get0_public_key(ec_key);
        if (PK_recipient == nullptr) {
            SEC_LOG_ERROR("EC_KEY_get0_public_key failed");
            break;
        }
        EC_POINT_mul(group, shared_secret, nullptr, PK_recipient, sender_rand, ctx);

        // key_2_wrap_point is a point on the curve, we add the shared_secret
        // to it and send the result, the wrapped_key, to the receiver.
        wrapped_key = EC_POINT_new(group);
        if (wrapped_key == nullptr) {
            SEC_LOG_ERROR("EC_POINT_new failed");
            break;
        }
        EC_POINT_add(group, wrapped_key, key_2_wrap_point, shared_secret, ctx);

        // Dissect the wrapped point to get its coordinates
        x = BN_new();
        if (x == nullptr) {
            SEC_LOG_ERROR("BN_new failed");
            break;
        }
        y = BN_new();
        if (y == nullptr) {
            SEC_LOG_ERROR("BN_new failed");
            break;
        }

        // Dissect shared_secret to get its coordinates and output them
        EC_POINT_get_affine_coordinates_GFp(group, sender_share, x, y, ctx);

        if (BigNumToBuffer(x, &output[0 * SEC_ECC_NISTP256_KEY_LEN], SEC_ECC_NISTP256_KEY_LEN) !=
                SEC_RESULT_SUCCESS) {
            SEC_LOG_ERROR("SecUtils_BigNumToBuffer failed");
            break;
        }

        if (BigNumToBuffer(y, &output[1 * SEC_ECC_NISTP256_KEY_LEN], SEC_ECC_NISTP256_KEY_LEN) !=
                SEC_RESULT_SUCCESS) {
            SEC_LOG_ERROR("SecUtils_BigNumToBuffer failed");
            break;
        }

        // Dissect wrapped_key to get its coordinates and output them
        EC_POINT_get_affine_coordinates_GFp(group, wrapped_key, x, y, ctx);

        if (BigNumToBuffer(x, &output[2 * SEC_ECC_NISTP256_KEY_LEN], SEC_ECC_NISTP256_KEY_LEN) !=
                SEC_RESULT_SUCCESS) {
            SEC_LOG_ERROR("SecUtils_BigNumToBuffer failed");
            break;
        }

        if (BigNumToBuffer(y, &output[3 * SEC_ECC_NISTP256_KEY_LEN], SEC_ECC_NISTP256_KEY_LEN) !=
                SEC_RESULT_SUCCESS) {
            SEC_LOG_ERROR("SecUtils_BigNumToBuffer failed");
            break;
        }

        res = 4 * SEC_ECC_NISTP256_KEY_LEN;
    } while (false);

    if (nullptr != x)
        BN_free(x);
    if (nullptr != y)
        BN_free(y);
    if (nullptr != inputAsBN)
        BN_free(inputAsBN);
    if (nullptr != sender_rand)
        BN_free(sender_rand);
    if (nullptr != shared_secret)
        EC_POINT_free(shared_secret);
    if (nullptr != sender_share)
        EC_POINT_free(sender_share);
    if (nullptr != key_2_wrap_point)
        EC_POINT_free(key_2_wrap_point);
    if (nullptr != wrapped_key)
        EC_POINT_free(wrapped_key);
    BN_CTX_free(ctx);

    return res;
}

static int ElGamal_Encrypt(EC_KEY* ec_key, SEC_BYTE* input, SEC_SIZE inputSize, SEC_BYTE* output,
        SEC_SIZE outputSize) {
    // Generate random number 'w' (multiplier) for the sender
    BIGNUM* sender_rand = BN_new();

    if (sender_rand == nullptr) {
        SEC_LOG_ERROR("BN_new failed");
        return -1;
    }
    if (BN_rand(sender_rand, 256, -1, 0) == 0) {
        SEC_LOG_ERROR("BN_rand failed");
        if (nullptr != sender_rand)
            BN_free(sender_rand);
        return -1;
    }

    return ElGamal_Encrypt_Rand(ec_key, input, inputSize, output, outputSize, sender_rand);
}

static std::vector<SEC_BYTE> opensslRsaCrypt(RSA* rsa, Sec_CipherAlgorithm algorithm, Sec_CipherMode mode,
        const std::vector<SEC_BYTE>& input) {
    int padding;
    if (algorithm == SEC_CIPHERALGORITHM_RSA_PKCS1_PADDING) {
        padding = RSA_PKCS1_PADDING;
    } else {
        padding = RSA_PKCS1_OAEP_PADDING;
    }

    int openssl_res;
    std::vector<SEC_BYTE> output;
    output.resize(RSA_size(rsa));

    if (mode == SEC_CIPHERMODE_ENCRYPT || mode == SEC_CIPHERMODE_ENCRYPT_NATIVEMEM) {
        openssl_res = RSA_public_encrypt(static_cast<int>(input.size()), &input[0], &output[0], rsa, padding);
    } else {
        openssl_res = RSA_private_decrypt(static_cast<int>(input.size()), &input[0], &output[0], rsa, padding);
    }

    if (openssl_res < 0) {
        SEC_LOG_ERROR("%s", ERR_error_string(ERR_get_error(), nullptr));
        return {};
    }

    output.resize(openssl_res);

    return output;
}

static Sec_Result RSAToDERPrivKeyInfo(RSA* rsa, SEC_BYTE* output, SEC_SIZE out_len, SEC_SIZE* written) {
    BIO* bio = nullptr;
    EVP_PKEY* evp_key = nullptr;
    BUF_MEM* bptr = nullptr;
    Sec_Result result = SEC_RESULT_FAILURE;

    do {
        evp_key = EVP_PKEY_new();
        if (EVP_PKEY_set1_RSA(evp_key, rsa) == 0) {
            SEC_LOG_ERROR("EVP_PKEY_set1_RSA failed");
            break;
        }

        bio = BIO_new(BIO_s_mem());
        if (bio == nullptr) {
            SEC_LOG_ERROR("BIO_new(BIO_s_mem()) failed");
            break;
        }

        if (i2d_PKCS8PrivateKeyInfo_bio(bio, evp_key) < 0) {
            SEC_LOG_ERROR("I2d_PKCS8_PRIV_KEY_INFO_bio failed");
            break;
        }

        BIO_flush(bio);
        BIO_get_mem_ptr(bio, &bptr); // NOLINT

        *written = bptr->length;

        if (output != nullptr) {
            if (out_len < bptr->length) {
                SEC_LOG_ERROR("Output buffer is not large enough");
                break;
            }
            memcpy(output, bptr->data, bptr->length);
        }

        result = SEC_RESULT_SUCCESS;
    } while (false);

    SEC_EVPPKEY_FREE(evp_key);
    SEC_BIO_FREE(bio);

    return result;
}

static std::vector<SEC_BYTE> toPkcs8(RSA* rsa) {
    std::vector<SEC_BYTE> pkcs8;
    pkcs8.resize(SEC_KEYCONTAINER_MAX_LEN);
    SEC_SIZE pkcs8_len;

    if (RSAToDERPrivKeyInfo(rsa, &pkcs8[0], pkcs8.size(), &pkcs8_len) != SEC_RESULT_SUCCESS) {
        SEC_LOG_ERROR("SecUtils_RSAToDERPriv failed");
        return {};
    }

    pkcs8.resize(pkcs8_len);

    return pkcs8;
}

template<typename T>
std::vector<T> concat(std::vector<T>& a, std::vector<T>& b) {
    std::vector<T> ret = std::vector<T>();
    std::copy(a.begin(), a.end(), std::back_inserter(ret));
    std::copy(b.begin(), b.end(), std::back_inserter(ret));
    return ret;
}

ProvKey* TestCreds::wrapAesWithEc(const SEC_BYTE* clear, Sec_KeyType type, EC_KEY* ec_key, SEC_OBJECTID wrappingId,
        Sec_CipherAlgorithm asymAlg) {
    std::vector<SEC_BYTE> payload;
    payload.resize(32);

    if (type == SEC_KEYTYPE_AES_128) {
        memcpy(&payload[0], clear, SEC_AES_BLOCK_SIZE);
        memcpy(&payload[16], clear, SEC_AES_BLOCK_SIZE);
    } else {
        memcpy(&payload[0], clear, 32);
    }

    std::vector<SEC_BYTE> encrypted;
    encrypted.resize(SEC_ECC_NISTP256_KEY_LEN * 4);

    int encrypted_len = ElGamal_Encrypt(ec_key, &payload[0], payload.size(), &encrypted[0],
            encrypted.size());

    if (encrypted_len <= 0) {
        SEC_LOG_ERROR("_ElGamal_Encrypt failed");
        return nullptr;
    }

    encrypted.resize(encrypted_len);

    std::vector<SEC_BYTE> res;
    res.resize(SEC_KEYCONTAINER_MAX_LEN);
    SEC_SIZE res_len;
    if (SecKey_GenerateWrappedKeyAsn1Off(&encrypted[0], encrypted.size(), type, wrappingId, nullptr, asymAlg, &res[0],
                res.size(), &res_len, 32 - SecKey_GetKeyLenForKeyType(type)) != SEC_RESULT_SUCCESS) {
        SEC_LOG_ERROR("SecKey_GenerateWrappedKeyAsn1 failed");
        return nullptr;
    }
    res.resize(res_len);

    return new ProvKey(res, SEC_KEYCONTAINER_ASN1);
}

ProvKey* TestCreds::wrapAesWithRsa(const SEC_BYTE* data, Sec_KeyType type, RSA* rsa_key, SEC_OBJECTID wrappingId,
        Sec_CipherAlgorithm asymAlg) {
    std::vector<SEC_BYTE> clear(data, data + SecKey_GetKeyLenForKeyType(type));
    std::vector<SEC_BYTE> wrapped = opensslRsaCrypt(rsa_key, asymAlg, SEC_CIPHERMODE_ENCRYPT, clear);

    if (wrapped.empty()) {
        SEC_LOG_ERROR("OpensslRsaCrypt failed");
        return nullptr;
    }

    std::vector<SEC_BYTE> res;
    res.resize(SEC_KEYCONTAINER_MAX_LEN);
    SEC_SIZE res_len;

    if (SecKey_GenerateWrappedKeyAsn1(&wrapped[0], wrapped.size(), type, wrappingId, nullptr, asymAlg, &res[0],
                res.size(), &res_len) != SEC_RESULT_SUCCESS) {
        SEC_LOG_ERROR("SecKey_GenerateWrappedKeyAsn1 failed");
        return nullptr;
    }

    return new ProvKey(res, SEC_KEYCONTAINER_ASN1);
}

ProvKey* TestCreds::wrapAesWithAes(const SEC_BYTE* clear, Sec_KeyType type, const SEC_BYTE* wrapping,
        Sec_KeyType wrappingType, SEC_OBJECTID wrappingId, Sec_CipherAlgorithm symAlg) {
    std::vector<SEC_BYTE> iv = TestCtx::random(SEC_AES_BLOCK_SIZE);

    TestCtx ctx;
    ctx.init();

    if (ctx.provisionKey(wrappingId, SEC_STORAGELOC_RAM, wrapping, SecKey_GetKeyLenForKeyType(wrappingType),
                wrappingType == SEC_KEYTYPE_AES_128 ? SEC_KEYCONTAINER_RAW_AES_128 : SEC_KEYCONTAINER_RAW_AES_256) ==
            nullptr) {
        SEC_LOG_ERROR("TestCtx::provisionKey failed");
        return nullptr;
    }

    std::vector<SEC_BYTE> wrapped;
    wrapped.resize(SEC_KEYCONTAINER_MAX_LEN);
    SEC_SIZE wrapped_len;
    if (SecUtils_WrapSymetric(ctx.proc(), wrappingId, symAlg, &iv[0], const_cast<SEC_BYTE*>(clear),
                SecKey_GetKeyLenForKeyType(type), &wrapped[0], wrapped.size(), &wrapped_len) !=
            SEC_RESULT_SUCCESS) {
        SEC_LOG_ERROR("SecUtils_WrapSymetric failed");
        return nullptr;
    }
    wrapped.resize(wrapped_len);

    std::vector<SEC_BYTE> asn1;
    asn1.resize(SEC_KEYCONTAINER_MAX_LEN);
    SEC_SIZE asn1_len;

    if (SecKey_GenerateWrappedKeyAsn1(&wrapped[0], wrapped.size(), type, wrappingId, &iv[0], symAlg, &asn1[0],
                asn1.size(), &asn1_len) != SEC_RESULT_SUCCESS) {
        SEC_LOG_ERROR("SecKey_GenerateWrappedKeyAsn1 failed");
        return nullptr;
    }
    asn1.resize(asn1_len);

    return new ProvKey(asn1, SEC_KEYCONTAINER_ASN1);
}

ProvKey* TestCreds::wrapRsaWithAes(RSA* rsa, const SEC_BYTE* wrapping, Sec_KeyType wrappingType,
        SEC_OBJECTID wrappingId, Sec_CipherAlgorithm symAlg) {
    std::vector<SEC_BYTE> iv = TestCtx::random(SEC_AES_BLOCK_SIZE);

    TestCtx ctx;
    ctx.init();

    if (ctx.provisionKey(wrappingId, SEC_STORAGELOC_RAM, wrapping, SecKey_GetKeyLenForKeyType(wrappingType),
                wrappingType == SEC_KEYTYPE_AES_128 ? SEC_KEYCONTAINER_RAW_AES_128 : SEC_KEYCONTAINER_RAW_AES_256) ==
            nullptr) {
        SEC_LOG_ERROR("TestCtx::provisionKey failed");
        return nullptr;
    }

    std::vector<SEC_BYTE> pkcs8 = toPkcs8(rsa);
    if (pkcs8.empty()) {
        SEC_LOG_ERROR("ToPkcs8 failed");
        return nullptr;
    }
    Sec_KeyType type = (RSA_size(rsa) == 128) ? SEC_KEYTYPE_RSA_1024 : SEC_KEYTYPE_RSA_2048;

    std::vector<SEC_BYTE> wrapped;
    wrapped.resize(SEC_KEYCONTAINER_MAX_LEN);
    SEC_SIZE wrapped_len;
    if (SecUtils_WrapSymetric(ctx.proc(), wrappingId, symAlg, &iv[0], &pkcs8[0], pkcs8.size(), &wrapped[0],
                wrapped.size(), &wrapped_len) != SEC_RESULT_SUCCESS) {
        SEC_LOG_ERROR("SecUtils_WrapSymetric failed");
        return nullptr;
    }
    wrapped.resize(wrapped_len);

    std::vector<SEC_BYTE> asn1;
    asn1.resize(SEC_KEYCONTAINER_MAX_LEN);
    SEC_SIZE asn1_len;

    if (SecKey_GenerateWrappedKeyAsn1(&wrapped[0], wrapped.size(), type, wrappingId, &iv[0], symAlg, &asn1[0],
                asn1.size(), &asn1_len) != SEC_RESULT_SUCCESS) {
        SEC_LOG_ERROR("SecKey_GenerateWrappedKeyAsn1 failed");
        return nullptr;
    }
    asn1.resize(asn1_len);

    return new ProvKey(asn1, SEC_KEYCONTAINER_ASN1);
}

std::vector<ProvKey> TestCreds::getWrappedContentKeyChainEcAes(TestKey contentKey, TestKc kc, SEC_OBJECTID base_id,
        Sec_CipherAlgorithm asymAlg) {
    std::vector<ProvKey> res;

    //generate key0
    std::shared_ptr<ProvKey> provKey(TestCreds::getKey(TESTKEY_EC_PRIV, kc, base_id));
    res.push_back(*provKey);

    //generate key1
    std::shared_ptr<EC_KEY> ec_key(TestCreds::asOpenSslEcKey(TESTKEY_EC_PRIV), EC_KEY_free);
    std::shared_ptr<ProvKey> wrappedKey1(
            wrapAesWithEc(TestCreds::asOpenSslAes(contentKey).data(), TestCreds::getKeyType(contentKey), ec_key.get(),
                    base_id, asymAlg));
    res.push_back(*wrappedKey1);

    return res;
}

std::vector<ProvKey> TestCreds::getWrappedContentKeyChainEcAesAes(TestKey contentKey, TestKc kc, SEC_OBJECTID base_id,
        Sec_KeyType aesType, Sec_CipherAlgorithm asymAlg, Sec_CipherAlgorithm symAlg) {
    std::vector<ProvKey> res;

    //generate key0
    std::shared_ptr<ProvKey> provKey(TestCreds::getKey(TESTKEY_EC_PRIV, kc, base_id));

    res.push_back(*provKey);

    //generate key1
    std::shared_ptr<EC_KEY> ec_key(TestCreds::asOpenSslEcKey(TESTKEY_EC_PRIV), EC_KEY_free);
    std::vector<SEC_BYTE> key1 = TestCtx::random(SecKey_GetKeyLenForKeyType(aesType));
    while (!Is_Valid_Point(ec_key.get(),
            (SecKey_GetKeyLenForKeyType(aesType) == SEC_AES_BLOCK_SIZE) ? concat(key1, key1) : key1)) {
        SEC_PRINT("Not a valid point.  Regenerating.\n");
        key1 = TestCtx::random(SecKey_GetKeyLenForKeyType(aesType));
    }

    std::shared_ptr<ProvKey> wrappedKey1(wrapAesWithEc(&key1[0], aesType, ec_key.get(), base_id, asymAlg));
    if (wrappedKey1 == nullptr)
        return res;

    res.push_back(*wrappedKey1);

    //generate key2
    std::shared_ptr<ProvKey> wrappedKey2(
            wrapAesWithAes(TestCreds::asOpenSslAes(contentKey).data(), TestCreds::getKeyType(contentKey), &key1[0],
                    aesType, base_id + 1, symAlg));
    if (wrappedKey2 == nullptr)
        return res;

    res.push_back(*wrappedKey2);

    return res;
}

std::vector<ProvKey> TestCreds::getWrappedContentKeyChainRsaAesRsaAesAes(TestKey contentKey, TestKc kc,
        SEC_OBJECTID base_id, Sec_KeyType rsaType,
        Sec_CipherAlgorithm asymAlg,
        Sec_KeyType aesType,
        Sec_CipherAlgorithm symAlg,
        Sec_CipherAlgorithm ckSymAlg) {
    std::vector<ProvKey> res;

    //generate key0
    TestKey rsaPrivKey = (rsaType == SEC_KEYTYPE_RSA_1024) ? TESTKEY_RSA1024_KEK_PRIV : TESTKEY_RSA2048_KEK_PRIV;
    std::shared_ptr<ProvKey> provKey(TestCreds::getKey(rsaPrivKey, kc, base_id));
    res.push_back(*provKey);

    //generate key1
    std::vector<SEC_BYTE> key1 = TestCtx::random(SecKey_GetKeyLenForKeyType(aesType));
    std::shared_ptr<RSA> rsa_key(TestCreds::asOpenSslRsa(rsaPrivKey), RSA_free);
    std::shared_ptr<ProvKey> wrappedKey1(wrapAesWithRsa(&key1[0], aesType, rsa_key.get(), base_id, asymAlg));
    if (wrappedKey1 == nullptr)
        return res;

    res.push_back(*wrappedKey1);

    //generate key2
    std::shared_ptr<ProvKey> wrappedKey2(wrapRsaWithAes(rsa_key.get(), &key1[0], aesType, base_id + 1, symAlg));
    if (wrappedKey2 == nullptr)
        return res;

    res.push_back(*wrappedKey2);

    //generate key3
    std::vector<SEC_BYTE> key3 = TestCtx::random(SecKey_GetKeyLenForKeyType(aesType));
    std::shared_ptr<ProvKey> wrappedKey3(wrapAesWithRsa(&key3[0], aesType, rsa_key.get(), base_id + 2, asymAlg));
    if (wrappedKey3 == nullptr)
        return res;

    res.push_back(*wrappedKey3);

    //generate key4
    std::shared_ptr<ProvKey> wrappedKey4(
            wrapAesWithAes(TestCreds::asOpenSslAes(contentKey).data(), TestCreds::getKeyType(contentKey), &key3[0],
                    aesType, base_id + 3, ckSymAlg));
    if (wrappedKey4 == nullptr)
        return res;

    res.push_back(*wrappedKey4);

    return res;
}

std::vector<ProvKey> TestCreds::getWrappedContentKeyChainRsaAes(TestKey contentKey, TestKc kc, SEC_OBJECTID base_id,
        Sec_KeyType rsaType, Sec_CipherAlgorithm asymAlg) {
    std::vector<ProvKey> res;

    //generate key0
    TestKey rsaKey = (rsaType == SEC_KEYTYPE_RSA_1024) ? TESTKEY_RSA1024_KEK_PRIV : TESTKEY_RSA2048_KEK_PRIV;
    std::shared_ptr<ProvKey> provKey(TestCreds::getKey(rsaKey, kc, base_id));
    res.push_back(*provKey);

    //generate key1
    std::shared_ptr<RSA> rsa(TestCreds::asOpenSslRsa(rsaKey), RSA_free);
    std::shared_ptr<ProvKey> wrappedKey1(
            wrapAesWithRsa(TestCreds::asOpenSslAes(contentKey).data(), TestCreds::getKeyType(contentKey), rsa.get(),
                    base_id, asymAlg));
    res.push_back(*wrappedKey1);

    return res;
}

std::vector<ProvKey> TestCreds::getWrappedContentKeyChainRsaAesAes(TestKey contentKey, TestKc kc, SEC_OBJECTID base_id,
        Sec_KeyType rsaType, Sec_CipherAlgorithm asymAlg,
        Sec_KeyType aesType, Sec_CipherAlgorithm symAlg) {
    std::vector<ProvKey> res;

    //generate key0
    TestKey rsaPrivKey = (rsaType == SEC_KEYTYPE_RSA_1024) ? TESTKEY_RSA1024_KEK_PRIV : TESTKEY_RSA2048_KEK_PRIV;
    std::shared_ptr<ProvKey> provKey(TestCreds::getKey(rsaPrivKey, kc, base_id));
    res.push_back(*provKey);

    //generate key1
    std::vector<SEC_BYTE> key1 = TestCtx::random(SecKey_GetKeyLenForKeyType(aesType));

    std::shared_ptr<RSA> rsa_key(TestCreds::asOpenSslRsa(rsaPrivKey), RSA_free);
    std::shared_ptr<ProvKey> wrappedKey1(wrapAesWithRsa(&key1[0], aesType, rsa_key.get(), base_id, asymAlg));
    if (wrappedKey1 == nullptr)
        return res;

    res.push_back(*wrappedKey1);

    //generate key2
    std::shared_ptr<ProvKey> wrappedKey2(
            wrapAesWithAes(TestCreds::asOpenSslAes(contentKey).data(), TestCreds::getKeyType(contentKey), &key1[0],
                    aesType, base_id + 1, symAlg));
    if (wrappedKey2 == nullptr)
        return res;

    res.push_back(*wrappedKey2);

    return res;
}
